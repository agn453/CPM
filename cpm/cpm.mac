	title	CPM emulator
	ident	"V0.99"	; Pre-release version

;*******************************************************************
;
;	CPM - CP/M 2.2 BDOS/BIOS emulation for RSX280
;
;	Initially developed for UZI280 by
;	Stefan Nitschke, 13.3.1996
;
;	Adaption and programming for RSX280 by
;	Tony Nicholson, 29-Apr-2020
;
;  This program is free software; you can redistribute it and/or
;  modify it under the terms of the GNU General Public License as
;  published by the Free Software Foundation; either version of
;  the License, or (at your option) any later version.
;
;  This program is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this program; if not, write to the Free Software
;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
;
;*******************************************************************

	.Z280		; RSX280 and Z280 only for now.
			; (The RSX180 operating system
			; uses Page zero of a task for
			; system calls and RST 0 for an
			; illegal instruction handler -
			; so this rules out a port to
			; RSX180).

FALSE	equ	0
TRUE	equ	not FALSE

ETX	equ	03h
BS	equ	08h
CR	equ	0Dh
LF	equ	0Ah
FF	equ	0Ch
TAB	equ	09h
EOF	equ	1Ah
RUBOUT	equ	7Fh

RSX280	equ	TRUE

UZI280	equ	not RSX280	; original code preserved

DEBUG	equ	TRUE		; output debugging messages

; CP/M memory sizing
memsize	equ	60		; 60KB memory size
topmem	equ	memsize*1024
cpmoffset equ	topmem-20*1024	; based on standard CP/M 2.2

; Where CP/M expects things to be
cpmfcb1	equ	0005ch		; FCB 1
cpmfcb2	equ	0006ch		; FCB 2
cpmdma	equ	00080h		; Default DMA address and command line
cpmtpa	equ	00100h		 ; Transient programs are loaded here
cpmccp	equ	03400h+cpmoffset ; CCP is implemented by this program
cpmbdos	equ	03c00h+cpmoffset ; BDOS contains emulation code
cpmbios	equ	04a00h+cpmoffset ; BIOS only emulates character I/O

  if RSX280

	; RSX280 definitions (list off)
	list	off
    ifdef ZXCC
	; cross-compile with include files in current directory
	include SYSFN.INC
	include FCB.INC
	include	DCB.INC
	include	TCB.INC
	include	QIO.INC
	include	FCSLIB.INC
	include	ERRORS.INC
    else
	; native RSX280 has include files in LB:[SYSTEM]
	include $SYSFN.INC
	include $FCB.INC
	include	$DCB.INC
	include	$TCB.INC
	include	$QIO.INC
	include	$FCSLIB.INC
	include	$ERRORS.INC
    endif ;ZXCC
	list	on

	extrn	PFN
	extrn	FCREAT,FOPEN,FCLOSE,FREAD,FWRITE

  endif ;RSX280

  if UZI280

stdin	equ	0
stdout	equ	1
stderr	equ	2

; UZI280 ioctl function number get available chars
TIOCSETN	equ	2

flag_r	equ	0	; R mode for file open()
flag_w	equ	1	; W mode for file open()
flag_rw	equ	2	; R/W mode for file open()

  endif ;UZI280

  if RSX280

LUNFL1	equ	1	; Emulator file access LUN #1
LUNFL2	equ	2	; Emulator file access LUN #2
LUNFL3	equ	3	; Emulator file access LUN #3
LUNFL4	equ	4	; Emulator file access LUN #4
LUNTI	equ	5	; Terminal Interface LUN (TI:)

TIEFN	equ	1	; event flag for AST terminal input
TOEFN	equ	2	; event flag for console output
FIOEFN	equ	3	; event flag for file I/O

; Console terminal queue offsets
TQ.IP	equ	0	; input pointer
TQ.OP	equ	TQ.IP+1	; output pointer
TQ.BUF	equ	TQ.OP+1	; buffer

flag_r	equ	1 SHL FM.RD	; R mode for file open()
				; (R opens an existing file)
flag_w	equ	1 SHL FM.WR	; W mode for file open()
				; (W creates a new file verson)
flag_rw	equ	(1 SHL FM.RD) OR (1 SHL FM.WR)	; R/W mode for file open()
				; (RW opens an existing file)

  endif ;RSX280
	page
;*******************************************************************

	cseg	; The majority of the emulator is in the code segment

; CP/M transient program .COM files are loaded here
tpa::
	jp	main		; command line processing

	;Under UZI280 the emulated program (minus the first
	;three bytes) are patched into this image (cpm.bin)
	;by overlaying it into the TPA region - see PATCH.C
	;from the UZI CPMEMU distribution.

	;For RSX280 we load the CP/M .COM file into the TPA
	;region ourselves (essentially this program behaves
	;functionally like the CP/M Console Command Processor).
	;A future enhancement may be to include loading the
	;Digital Research CCP from CP/M 2.2 or one of its
	;replacements.

; One big region to load CP/M binaries into

	defs	cpmbdos-cpmtpa-3 ; Rest of TPA

;*******************************************************************
;
; BDOS emulator
;
; This is at the standard CP/M 2.2 address for programs
; to access.  The emulator set-up and control routines
; are embedded here too.  These begin at the entry-point
; labelled MAIN.  When an emulated program exits, it
; either does a Warm Boot (JP 0/RST 0) or return (if the
; stack hasn't been modified) and the emulator closes any
; open files and prompts for the next CP/M command.
; To exit back to RSX280, type Ctrl-Z then Return to the
; X> prompt.
;
bdos::
	jp	entry		; make the BDOS look like real CP/M
	nop			; (it starts with a JP instruction
	nop			; followed by 3 NOPs)
	nop
entry:
	ld	hl,0
	add	hl,sp		; get stack
	ld	(oldstk),hl
	ld	hl,tmpstk
	ld	sp,hl		; new stack
	ex	de,hl
	ld	(arg),hl
	ld	a,c
	ld	(call),a 	; BDOS function number
	push	ix
	push	hl
	pop	ix		; (arg) into IX
	call	bdos2
	pop	ix
	ex	de,hl		; save return val in DE
	ld	hl,(oldstk)
	ld	sp,hl
	ld	hl,(arg)
	ex	de,hl		; restore orig contents of DE
	ld	a,(call)
	ld	c,a		; restore original contents of C
	ld	a,l		; get return value into A
	ld	b,h		; and B for strict compatibility
	ret

bdos2:
	cp	maxbdosfn+1
	ret	nc		; function number too big
	add	a,a
	ld	hl,bdostable	; index into table
	add	hl,a
	ld	hl,(hl)
	jp	(hl)		; go there, function just returns above

;*******************************************************************
; Convert CP/M FCB name to UZI or RSX file name in variable u_name
; Illegal filename characters are replaced with a dash "-".
;
; on entry: IX -> pointer to FCB
;
; on exit : HL -> pointer to string.
;	    DE -> pointer to EOS.
getname:
	ld	de,u_name
	lda	hl,(ix+fcbname)	; get address of name
	ld	b,8
g_l1:	ld	a,(hl)
	inc	hl
	cp	0
	jr	z,g_l2
	cp	' '
	jr	z,g_l2
  if UZI280
	call	LCASE
  endif ;UZI280
  if RSX280
	call	chmap
  endif ;RSX280
	ld	(de),a
	inc	de
	djnz	g_l1
g_l2:
	lda	hl,(ix+fcbext)	; get address of file extension
	ld	a,(hl)
	cp	' '
	jr	z,g_l4		; no extension if blank
	ld	a,'.'
	ld	(de),a
	inc	de
	ld	b,3
g_l3:
	ld	a,(hl)
	inc	hl
	or	a
	jr	z,g_l4
	cp	' '
	jr	z,g_l4
  if UZI280
	call	LCASE
  endif ;UZI280
  if RSX280
	call	chmap
  endif ;RSX280
	ld	(de),a
	inc	de
	djnz	g_l3
g_l4:
	xor	a
	ld	(de),a		; terminate the string with a NUL
	ld	hl,u_name	; return pointer to name
	ret

;*******************************************************************
; BDOS call return version number
return_version:
	ld	hl,022h		; pretend to be CP/M 2.2
	ret

;*******************************************************************
; BDOS call set dma address
set_dma:
	ld	hl,(arg)
	ld	(dmaadr),hl
	ret

;*******************************************************************
; BDOS call reset dma address
reset_dma:
	ld	hl,080h
	ld	(dmaadr),hl
	ret

;*******************************************************************
; BDOS call console input status
console_status:
	call	char_avail
	ld	a,l
	or	h
	ret	z		; no char available
	ld	hl,0ffh
	ret

;*******************************************************************
; BDOS call write string
print_string:

  if UZI280
	ld	de,0
	ld	hl,(arg)
pr_lop:	ld	a,(hl)
	inc	de
	inc	hl
	cp	'$'
	jr	nz,pr_lop
	dec	de		; forget the '$'
	push	stdout
	push	ix		; (arg)
	push	de		; count
	call	_write
;	write(1, arg, cnt);
	pop	de
	pop	de
	pop	de
  endif ;UZI280

  if RSX280
	push	hl
	ld	hl,(arg)
pr_lop:	ld	a,(hl)
	cp	'$'
	jr	z,pr_done
	call	$TTOUT
	inc	hl
	jr	pr_lop
pr_done:
	pop	hl
  endif ;RSX280

	ret

;*******************************************************************
; BDOS call direct console IO
direct_console:
	ld	a,(arg)
	cp	0ffh
	jr	nz,write_console
	call	char_avail
;	cpw	hl,0
	ld	a,h
	or	l
	ret	z		; no char available, return zero
	call	readchar
	ld	a,(char)
  if UZI280
;	if (c == '\n') c = '\r';
	cp	LF		; '\n'
	jr	nz,di_01
	ld	a,CR		; '\r'
di_01:
  endif ;UZI280
	ld	l,a
	ld	h,0
	ret

;*******************************************************************
; BDOS call write console
write_console:
	ld	a,(arg)
  if UZI280
;	if (arg == '\r') return(0)
	cp	CR
	ret	z
  endif ;UZI280
	ld	(char),a
	call	writechar
	ret

;*******************************************************************
; BDOS call read console.
read_console:
	call	readchar
	ld	a,(char)
  if UZI280
	cp	LF		;'\n'
	jr	nz,rc_1
;	if (c == '\n') c = '\r';
	ld	a,CR		;'\r'
rc_1:
  endif ;UZI280
	ld	l,a
	ld	h,0
	ret

;*******************************************************************
; BDOS call read console buffer

  if UZI280

;    int nread;
;
;    nread = read(0, arg+2, *arg & 0xff );
;    --nread;  /* Forget about newline */
;    arg[nread+2] = 0;   /* Remove newline */
;    arg[1] = nread;
;    return(nread);

rdbuf:	ld	hl,(arg)
;	cpw	hl,0
	ld	a,h
	or	l
	jr	nz,rdb_1
	ld	hl,080h		; default dma buffer
	ld	(arg),hl
	ld	a,0ffh
	jr	rdb_2
rdb_1:	ld	a,(hl)
rdb_2:	inc	hl
	inc	hl
	push	stdin
	push	hl		; arg+2
	ld	h,0
	ld	l,a
	push	hl		; *arg & 0xff
	call	_read
	pop	de
	pop	de
	pop	de
	dec	hl		; --nread
	ex	de,hl
	ld	hl,(arg)
	inc	hl
	ld	(hl),e		; count
	inc	hl
	add	hl,de
	xor	a
	ld	(hl),a		; remove nl
	ex	de,hl		; return nread
	ret

  endif ;UZI280

  if RSX280
	; We'll use code similar to the original DRI BDOS for
	; reading the console buffer (for an authentic "feel")

rdbuf:	ld	a,(curpos)	; save cursor position
	ld	(starting),a	;  for processing Ctrl-X and Ctrl-H
	push	ix		; We'll use HL for buffer pointer
	pop	hl
;	cpw	hl,0		; Is pointer is zero?
	ld	a,h
	or	l
	jr	nz,rdbufg
	ld	hl,cpmdma	; Yes, use default DMA buffer
rdbufg:	ld	c,(hl)		; first byte is buffer size
	inc	hl
	push	hl		; save pointer to available space
	ld	b,0
rdbuf1:	push	bc
	push	hl
rdbuf2:	call	read_console	; Get next character
	and	7Fh		; strip parity
	pop	hl
	pop	bc
	cp	CR		; end of line?
	jp	z,rdbuf17
	cp	LF		; treat LF like a CR
	jp	z,rdbuf17
	cp	BS		; backspace?
	jr	nz,rdbuf3	; no
	ld	a,b		; yes, ignore at line beginning
	or	a
	jr	z,rdbuf1
	dec	b		; backup one character
	ld	a,(curpos)
	ld	(outflag),a
	jr	rdbuf10
rdbuf3:	cp	RUBOUT		; rubout?
	jr	nz,rdbuf4
	ld	a,b
	or	a		; ignore at start of line
	jr	z,rdbuf1
	ld	a,(hl)		; echo previous character
	dec	b
	dec	hl
	jr	rdbuf15
rdbuf4:	cp	05h		; physical line end (Ctrl-E)?
	jr	nz,rdbuf6
	push	bc
	push	hl
	call	outcrlf
	xor	a
	ld	(starting),a
	jr	rdbuf2
	; left out the detection of Ctrl-P for printer toggle
rdbuf6:	cp	18h		; cancel (Ctrl-X)?
	jr	nz,rdbuf8
	pop	hl
rdbuf7:	ld	a,(starting)	; backup the cursor
	ld	hl,curpos
	cp	(hl)
	jr	nc,rdbuf
	dec	(hl)		; move cursor back 1
	call	backup
	jr	rdbuf7
rdbuf8:	cp	15h		; Ctrl-U (cancel line)?
	jr	nz,rdbuf9
	call	newline
	pop	hl
	jp	rdbuf
rdbuf9:	cp	12h		; Ctrl-R?
	jr	nz,rdbuf14
rdbuf10:
	push	bc		; Re-type the current line
	call	newline
	pop	bc
	pop	hl		; HL back to beginning of line buf
	push	hl
	push	bc
rdbuf11:
	ld	a,b
	or	a		; Have we done the whole line yet?
	jr	z,rdbuf12
	inc	hl		; No, get next character
	ld	c,(hl)
	dec	b		; count it
	push	bc
	push	hl
	call	showit
	pop	hl
	pop	bc
	jr	rdbuf11
rdbuf12:
	push	hl
	ld	a,(outflag)
	or	a
	jr	z,rdbuf2
	ld	hl,curpos
	sub	(hl)
	ld	(outflag),a
rdbuf13:
	call	backup
	ld	hl,outflag
	dec	(hl)
	jr	nz,rdbuf13
	jp	rdbuf2
rdbuf14:
	inc	hl
	ld	(hl),a		; Store character in buffer
	inc	b		; and count it
rdbuf15:
	push	bc
	push	hl
	ld	c,a
	call	showit
	pop	hl
	pop	bc
	ld	a,(hl)		; Was it a Ctrl-C?
	cp	ETX
	ld	a,b
	jr	nz,rdbuf16
	cp	1		; Only if at start of line
	jp	z,$EXITC	; Exit program
rdbuf16:
	cp	c		; Have we filled the buffer?
	jp	c,rdbuf1	; No
rdbuf17:
	inc	hl		; Store the line terminator
	ld	(hl),a		;  in the buffer

	pop	hl		; Yes, end the line and return
	ld	(hl),b		; number of characters entered

;AGN - fall through to output CR,LF
;AGN	ld	c,CR
;AGN	jr	outchar

outcrlf:
	ld	c,CR
	call	outchar
	ld	c,LF
	jr	outchar

backup:	call	backup1
	ld	c,' '
	call	_conout
backup1:
	ld	c,BS
outchar:
	jp	_conout

chkchar:
	cp	CR
	ret	z
	cp	LF
	ret	z
	cp	TAB
	ret	z
	cp	BS
	ret	z
	cp	' '
	ret

showit:	ld	a,c
	call	chkchar
	jr	nc,outcon	; not a control char
	push	af
	ld	c,'^'		; output caret
	call	outchar
	pop	af
	or	'@'		; make it printable
	ld	c,a
outcon:	ld	a,c
	cp	09h		; tab?
	jr	nz,outchar
outcon1:
	ld	c,' '		; expand tabs to the right number
	call	outchar		;  of spaces
	ld	a,(curpos)
	and	07h
	jr	nz,outcon1
	ret

newline:
	ld	c,'#'		; signal a deleted line with a "#"
	call	outchar
	call	outcrlf
newln1:	ld	a,(curpos)	; move the cursor back to starting
	ld	hl,starting	; position
	cp	(hl)
	ret	nc
	ld	c,' '
	call	outchar
	jr	newln1

; Copy parameter pointer to by IX into the FCB pointed to by HL
;
;**TODO - wildcard characters * and ?
fillfcb:
	;assumes Drive field is always 0 - the current drive
	inc	ix
	push	ix		; save and init with spaces
	ld	b,8+3
	ld	a,' '
ff_blnk:
	ld	(ix+0),a
	inc	ix
	djnz	ff_blnk

	pop	ix
	ld	b,8		; name part is up to 8 chars
ff_nam:	ld	a,(ix+0)
	or	a		; end of string?
	ret	z
	cp	'.'		; filename delimeter
	jr	z,ff_ext
	call	delimiter	; is it a delimiter?
	ret	z		; yes - done
	ld	(hl),a		; store in FCB
	inc	ix
	inc	hl
	djnz	ff_nam
ff_skp:	ld	a,(ix+0)	; skip rest of name part
	or	a
	ret	z		; end of string - done
	cp	'.'
	jr	z,ff_exte
	call	delimiter
	ret	z		; delimiter - done
	jr	ff_skp
ff_ext:	inc	ix
ff_adv	inc	hl
	djnz	ff_adv		; point to ext part
ff_exte:
	ld	b,3
ff_enxt:
	ld	a,(ix+0)
	or	a
	ret	z		; end of string
	call	delimiter
	ret	z
	ld	(hl),a
	inc	ix
	inc	hl
	djnz	ff_enxt
	ret

; If A contains one of <=>:;_ then set Z flag bit
delimiter:
	cp	'<'
	ret	z
	cp	'='
	ret	z
	cp	'>'
	ret	z
	cp	':'
	ret	z
	cp	';'
	ret	z
	cp	'_'
	ret

  endif ;RSX280

;*******************************************************************
; BDOS call open file.
;
; On entry: IX -> pointer to FCB
;
openfile:
	; test for reopen
	ldw	hl,(ix+fcbmagic)
	cpw	hl,MAGIC
	jr	nz,open2
	ldw	hl,(ix+fcbdesc)
	push	hl
	call	_close		; was open
	pop	de
open2:
	call	getname		; convert to valid filename
	push	hl		; string address
	push	flag_rw
	call	_open		; open file for R/W
	pop	de
	pop	de
	cpw	hl,-1
  if RSX280
	jr	z,no_good	; we don't do search paths for now
  endif
  if UZI280
	jr	nz,open_ok

; open along search path
;	strcpy(p_name,SRCH_PATH);
	ld	de,p_name
	ld	hl,SRCHPATH
	call	strcpy		; advance string pointer
;	strcat(p_name,getname(blk));
	ld	hl,u_name
	call	strcpy
	push	p_name
	push	flag_rw
	call	_open		; open along new path
	pop	de
	pop	de
	cpw	hl,-1
	jp	z,no_good
  endif ;UZI280

open_ok:
	ldw	(ix+fcbdesc),hl
	ld	hl,MAGIC
	ldw	(ix+fcbmagic),hl
	ld	hl,0		; return no error
	ldw	(ix+fcbrec),hl
	ret
no_good:
	ld	hl,255		; return error
	ret

;*******************************************************************
; CPM bdos call to make (create) a file
;
; On entry: IX -> pointer to FCB
;
makefile:
	call	getname		; convert to valid filename
	push	hl		; str adr
	push	666Q
	call	_creat		; create the file
;    desc = creat(getname(blk), 0666);
	pop	de
	pop	de
	cpw	hl,-1
	jp	z,no_good
	push	hl
	call	_close		; close it
	pop	de
	ld	hl,u_name 	; same as second call to getname
	push	hl
	push	flag_rw
	call	_open		; and reopen for R/W
	pop	de
	pop	de
	cpw	hl,-1
	jp	z,no_good
;    blk->magic= MAGIC;
;    blk->desc = desc;
;    blk->rec  = 0;
	ldw	(ix+fcbdesc),hl
	ld	hl,MAGIC
	ldw	(ix+fcbmagic),hl
	ld	hl,0
	ldw	(ix+fcbrec),hl
	ret

;*******************************************************************
; BDOS call close file
;
; On entry: IX -> pointer to FCB
;
closefile:
	ldw	hl,(ix+fcbdesc)
	push	hl
	call	_close
	pop	de
	cpw	hl,-1
	jp	z,no_good
	ld	hl,0
	ldw	(ix+fcbmagic),hl
	ret

;*******************************************************************
; BDOS call delete file
;
; On entry: IX -> pointer to FCB
;
delete:
	call	getname
	push	hl
	call	_unlink
	pop	de
	cpw	hl,-1
	jp	z,no_good
	ld	hl,0
	ret

;*******************************************************************
; BDOS call rename file
;
; On entry: IX -> pointer to FCB
;
  if UZI280
;    static char cmd[40];
;    strcpy(cmd, "mv ");
;    strcat(cmd, getname(blk));
;    strcat(cmd, " ");
;    strcat(cmd, getname( (struct fcb *)&(blk->desc)));
;    system(cmd);
;    return(0);
rename:
	ld	hl,p_name
	ld	a,'m'
	ld	(hl),a
	inc	hl
	ld	a,'v'
	ld	(hl),a
	inc	hl
	ld	a,' '
	ld	(hl),a
	inc	hl
	push	hl		; save string pointer
	call	getname
	pop	de
	call	strcpy
	ld	a,' '
	ld	(de),a		; p_name = "mv oldname "
	inc	de
	push	de		; save string pointer
	ld	a,fcbdesc
	add	ix,a		; ix pointer to newname-1
	call	getname
	pop	de
	call	strcpy		; p_name = "mv oldname newname"
	call	_fork		; fork new process
	ld	(char),hl	; pid
;	cpw	hl,0
	ld	a,h
	or	l
	jr	nz,parent
	push	shell		; we are the child
	push	argv
	push	(environ)
	call	_execve		; should not return
;	execve("/bin/sh",argv,environ)
	pop	de
	pop	de
	pop	de
	ld	hl,127
	push	hl
	call	_exit		; return error code 127

parent:
	push	arg
	call	_wait
	pop	de
	cpw	hl,(char)
	jr	nz,parent	; wait for exited child
	ld	hl,(arg)	; return child exit status
	ret
  endif ;UZI280

  if RSX280
;**TODO
rename:
	ret
  endif

;*******************************************************************
; BDOS call read file seq.
;
; On entry: IX -> pointer to FCB
;
readfile:
	call	read128
;    nread = read(blk->desc, dmaadr, 128);
	cpw	hl,-1
	jp	z,no_good
	incw	(ix+fcbrec)
;    if (nread < 128)
;	dmaadr[nread] = 0x1a;
	ld	a,l
	cp	128
	jr	nc,r_ok
	ex	de,hl
	ld	hl,(dmaadr)
	add	hl,de
	ld	a,EOF
	ld	(hl),a
r_ok:
	ld	hl,0
	ret

;*******************************************************************
; BDOS function write file seq.
;
; On entry: IX -> pointer to FCB
;
writefile:
;ifdef EDITOR
;    register i;
;	/* write until CPM EOF (^Z) found */
;    i = 0;
;    while( (dmaadr[i] != 0x1A) && (i < 128) )
;	i++;
;    if (write(blk->desc, dmaadr, i) != i )
;#else
	call	write128
;    if (write(blk->desc, dmaadr, 128) != 128 )
	cpw	hl,128
	jp	nz,no_good
	incw	(ix+fcbrec)
	ld	hl,0
	ret

;*******************************************************************
; BDOS Random read/write. Max file length 8192 K
;
; On entry: IX -> pointer to FCB
;
setrandom:
	ldw	hl,(ix+fcbrec)
	ldw	(ix+fcbran),hl
	ret

readrandom:
	call	rseek
	call	read128
;    nread = read(blk->desc, dmaadr, 128);
    	call	rseek
	cpw	hl,-1
	jp	z,no_good
	ld	a,l
	cp	128		; nread < 128
	jr	nc,rr_1
	ld	hl,1		; EOF
	ret
rr_1:	ld	hl,0
	ret


writerandom:
	call	rseek
	call	write128
;    if ( write(blk->desc, dmaadr, 128) != 128 )
 	call	rseek
	cpw	hl,128
	jp	nz,no_good
	ld	hl,0
	ret

; record seek (128 byte) for read/write random
rseek:
	push	hl		; save HL
	ldw	hl,(ix+fcbdesc)
	push	hl
	ldw	hl,(ix+fcbran)
	ldw	(ix+fcbrec),hl
	ld	e,0
	ld	a,l
	and	011b		; a = ranrec % 4
	srl	a
	ld	d,a
	rr	e		; de = 128 * (ranrec % 4)
	push	de
	push	0
	call	_seek
;    seek(blk->desc,128*(blk->ranrec % 4), 0);  /* byte seek */
	pop	de
	pop	de
	pop	de

	ldw	hl,(ix+fcbdesc)
	push	hl
	ldw	hl,(ix+fcbran)
	srl	h
	rr	l		; HL / 2
	srl	h
	rr	l		; HL / 4
	push	hl
	push	3
	call	_seek
;    seek(blk->desc,     blk->ranrec / 4 , 3);  /* block seek (512byte) */
	pop	de
	pop	de
	pop	de
	pop	hl		; restore HL
	ret

;*******************************************************************
; Utility routines

  if UZI280
; convert an upper case letter in register A to lower case.
LCASE:
	cp	'A'
	ret	c
	cp	'Z'+1
	ret	nc
	add	a,32
	ret

  endif ;UZI280

  if RSX280

; Convert char in A to uppercase
UCASE:	cp	'a'
	ret	c
	cp	'z'+1
	ret	nc
	and	5Fh
	ret

; convert illegal RSX280 filename character to a '-'.
; (only A..Z and 0..9 are allowed).
chmap:
	and	07Fh		; no parity, 7-bit only
	cp	'0'
	jr	c,chill
	cp	'9'+1
	ret	c		; '0'-'9' is OK
	cp	'A'
	jr	c,chill
	cp	'Z'+1
	ret	c		; 'A'-'Z' is OK
	cp	'a'
	jr	c,chill
	cp	'z'+1
	jr	nc,chill
	sub	a,32		; 'a'-'z' is uppercased
	ret
chill:	ld	a,'-'		; Illegal is an '-'
	ret

; Get next non-blank char.
;
; On entry: HL -> character string
; On exit:  HL -> first non-space character in string
;	    Z flag set if end of string reached
;
getnb:	ld	a,(hl)
	or	a
	ret	z
	cp	' '
	ret	nz
	inc	hl
	jr	getnb

  endif ;RSX280

; Copy NUL terminated string pointed to by HL to DE
;
; Pointers are advanced to allow concatenation.
; The terminating NUL is copied.
strcpy:
s_lo:	ld	a,(hl)
	ld	(de),a
	or	a
	ret	z		; end of string
	inc	hl
	inc	de
	jr	s_lo

; return length of NUL terminated string pointed to by HL in A
strlen:
	push	bc
	ld	c,0
sl_lo:
	ld	a,(hl)
	or	a
	jr	z,sl_12
	inc	c
	inc	hl
	jr	sl_lo
sl_12:	ld	a,c
	pop	bc
	ret

; return number of available input chars in HL
char_avail:
  if UZI280
	push	stdin
	push	TIOCSETN
	push	char
	call	_ioctl
;	ioctl(0, TIOCSETN, &char);
	pop	de
	pop	de
	pop	de
	ld	hl,(char)
	ret
  endif ;UZI280

  if RSX280
	ld	hl,0
	push	de
	ld	e,TIEFN
	sc	.RDEF		; Read event-flag
	pop	de
	or	a		; Not set, nothing in buffer
	ret	z

	call	$TTGST		; Is there any char in queue?
	ret	z		; No, return 0 in HL and carry set
	ld	hl,(TTQ)	; TQ.IP in L, TQ.OP in H
	ld	a,l
	cp	h		; if TQ.OP > TQ.IP the ring
	jr	nc,ca_1		;  buffers have wrapped
	add	a,64		; (TTQ input queue is 64 bytes)
ca_1:	sub	h
	ld	h,0
	ld	l,a		; return count and carry clear
	ret
  endif ;RSX280

ret_0:
	ld	hl,0
	ret
ret_1:
	ld	hl,1
	ret

; read one character from stdin
readchar:
  if UZI280
	push	stdin
	push	char
	push	1
	call	_read
;	read(0,&char,1);
	pop	de
	pop	de
	pop	de
  endif ;UZI280

  if RSX280
	call	$TTGC		; get a character
	ld	(char),a
  endif ;RSX280
	ret

; write one char to stdout
writechar:
  if UZI280
	push	stdout
	push	char
	push	1
	call	_write
;	write(1,&char,1);
	pop	de
	pop	de
	pop	de
  endif ;UZI280

  if RSX280
	ld	a,(outflag)	; Check output flag
	or	a		; If it is non-zero, output nothing
	jr	nz,outchr1

	ld	a,(char)	; Output the character
	call	$TTOUT

outchr1:
	push	hl		; Update cursor position
	ld	hl,curpos
	cp	RUBOUT		; Rubouts don't do anything
	jr	z,wc_ret
	inc	(hl)		; Bump cursor
	cp	' '
	jr	nc,wc_ret	; Printing character
	dec	(hl)		; Backup cursor
	ld	a,(hl)		; Is it at start of line?
	or	a
	jr	z,wc_ret	; Yes, ignore it
	ld	a,(char)
	cp	BS		; Is it a backspace?
	jr	nz,wc_2
	dec	(hl)		; Yes, backup pointer by 1
	jr	wc_ret
wc_2:	cp	LF		; Is it a linefeed?
	jr	nz,wc_ret
	ld	(hl),0		; reset cursor to start of line
wc_ret:	pop	hl
	ret

  endif ;RSX280

	ret

; read 128 bytes
read128:
	ldw	hl,(ix+fcbdesc)
	push	hl
	push	(dmaadr)
	push	128
	call	_read
;    nread = read(blk->desc, dmaadr, 128);
	pop	de
	pop	de
	pop	de
	ret

; write 128 bytes
write128:
	ldw	hl,(ix+fcbdesc)
	push	hl
	push	(dmaadr)
	push	128
	call	_write
;    nread = write(blk->desc, dmaadr, 128);
	pop	de
	pop	de
	pop	de
	ret

;*******************************************************************
; CP/M Emulator set-up
;
; main(argc, argv)

main::
  if UZI280
	ld	hl,4
	add	hl,sp
	ld	(environ),hl	; save pointer to environ
	pop	hl		; get argv into HL
	pop	de		; get argc into DE
  endif

  if RSX280

	; We're running under RSX280

	ld	sp,tmpstk	; switch to local stack
	xor	a
	ld	(ttlc),a	; force input to uppercase

	ld	hl,luntb	; clear LUN table of
	ld	b,luntbsz	;  open files (all files
init_0:	ld	(hl),a		;  are closed)
	inc	hl
	djnz	init_0

	ldw	(CCFLG),0	; enable ctrl-C break
	ld	ix,TTQ

	call	qinit		; set-up terminal queue

	ld	de,'TI'
	ld	c,0
	ld	b,LUNTI
	SC	.ALUN		; assign TI: to LUNTI
	call	ATTACH		; attach with ASTs
	call	TTCLR		; clear output buffer

	call	$PRINT
	defb	CR,LF,'RSX280 CP/M emulator ',0
	ld	hl,VERSION
	call	$MSGHL
reentry:
	call	$FLINP		; flush input buffer
	call	$PRINT		; output prompt
	defb	'X>',0

	ld	a,2		; Cursor is at column 2 (counts from 0)
	ld	(curpos),a
	xor	a		; Reset flag to allow console echo
	ld	(outflag),a

	ld	hl,ttibuf
	push	hl
	pop	ix		; into IX too
	ld	e,ttibsz
	call	rdbuf
	ld	a,(ix+1)	; how many characters entered?
	or	a
	jr	z,reentry	; none

	ld	a,(ix+2)	; Look for Ctrl-Z
	cp	EOF
	jp	z,$EXIT		; Yes, exit

	call	getnb		; skip white-space
	jr	z,reentry	; there was nothing
	cp	CR		; EOL?
	jr	z,reentry

	; HL points to the first non-blank character
	ld	ix,p_argv	; IX -> first of the argv pointers
	call	getargs		; Split line into argv elements
	ld	(argc),hl	; save argc

	ld	hl,(p_argv)	; pointer to argv[0]
	ld	de,COMFCB
	call	strcpy		; copy it into filename
	ld	hl,DOTCOM
	call	strcpy		; add .COM file type

	push	COMFCB		; Open the COM file
	push	flag_r
	call	_open
	pop	de		; clean-up stack
	pop	de

	cpw	hl,-1
	jr	nz,arg_5	; opened

notfnd:
	call	$CRLF
	ld	hl,(p_argv)	; not found
	call	$MSGHL		; output argv[0] followed
	call	$PRINT		;  by a '?' for unknown
	defb	'?',CR,LF,0	;  command
	jp	reentry

arg_5:				; HL contains the LUN of opened file
	push	hl		; LUN to stack
	push	tpa		; TPA address to stack
ldcom1:	push	128		; number of bytes to read at a time
	call	_read		; Read sector into TPA
	jr	c,ldcom2	; An error? (most likely end of file)
	; number of bytes read returned in BC
	ld	h,b
	ld	l,c
;	cpw	hl,0		; nothing read?
	ld	a,h
	or	l
	jr	z,ldcom2
	pop	de		; remove nchars from stack
	pop	de		; buffer address from stack
	add	hl,de		; add number of bytes read
	cpw	hl,bdos		; don't overwrite the BDOS
	jr	nc,ldcom3	; too big
	push	hl
	jr	ldcom1		; next sector

ldcom3:
	call	_close
	pop	de
	call	$PRINT
	defb	'BAD LOAD',0
	jr	notfnd		; Error

ldcom2:	pop	de		; clean up stack (byte count)
	pop	(topcom)	; save top load address
	call	_close		; (LUN is still on the stack)
	pop	de		; discard it
	; .COM file loaded
    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%CPM-I-Program loaded 0100-',0
	ld	hl,(topcom)
	call	$HLHEX
	call	$CRLF
      if 0
	call	dumptpa		; Let's see a dump of the TPA
      endif
    endif ;DEBUG

	ld	hl,(topcom)
	cpw	hl,tpa		; Anything loaded?
	jp	z,notfnd	; No - treat as an error

	ld	hl,p_argv
	ld	de,(argc)
  endif
	;Now we assemble the command parameters at 0080h
	;argv in HL
	;argc in DE
	push	de
	ld	a,e
	cp	1
	jr	nz,m_33
	ldw	(cpmdma),0
	jp	m_2		; no file arguments
m_33:	ld	bc,0		; length counter
	push	bc
	ld	de,cpmdma+2	; CPM command line buffer
	push	hl		; save argv pointer
m_3:	pop	hl		; hl pointer to argv
	inc	hl
	inc	hl		; point to next argv
	push	hl		; save argv pointer
	ld	hl,(hl)
	ld	a,(hl)
	or	a
	jr	z,m_55		; no more args
	push	hl		; save argv[i]
	call	strcpy		; copy argument from (HL) to (DE)
	ld	a,' '		; strcpy advances DE
	ld	(de),a
	inc	de
	pop	hl		; get back argv
	call	strlen		; get length of argv[1] into a
	inc	a
	pop	hl
	pop	bc		; add string length
	add	a,c
	ld	c,a
	push	bc		; save length counter
	push	hl
	jr	m_3
m_55:	pop	hl		; forget argv pointer
	pop	bc		; get length
	xor	a
	ld	(de),a		; terminate the string
	ld	a,c		; get length
	ld	(cpmdma),a
	ld	a,' '
	ld	(cpmdma+1),a
m_2:
	ld	hl,cpmdma		; set default DMA address
	ld	(dmaadr),hl

	; now set-up the CP/M default
	; File Control Block at 005Ch

	ld	hl,cpmfcb1	; clear the FCB area
	ld	b,36
m_0:	ld	(hl),0
	inc	hl
	djnz	m_0

	pop	de		; restore argc
	ld	a,e
	cp	1		; No parameters
	jr	z,parm_0
	cp	2+1		; Two parameters?
	jr	c,parm_1	; No - must be only one
	ld	ix,p_argv+2*2	; Point IX to p_argv[2]
	ld	hl,cpmfcb2	; point HL to second FCB area
	call	fillfcb		; copy to FCB
parm_1:	ld	ix,p_argv+2*1	; point IX to p_argv[1]
	ld	hl,cpmfcb1	; point HL to first FCB area
	call	fillfcb
parm_0:

	; make BDOS and BIOS entry points

	ld	a,0c3h
	ld	(0000),a
	ld	(0005),a
	ld	hl,bios
	ld	(0001),hl
	ld	hl,bdos
	ld	(0006),hl

  if 0 ;DEBUG
	push	hl
	call	dumppg0		; Show page zero to see it's all OK
	pop	hl
  endif

	ld	a,0ffh		; enable lowercase input
	ld	(ttlc),a

  if not DEBUG
	ldw	(CCFLG),0FFFFh	; disable Ctrl-C checking
  endif

	ld	sp,hl		; set stack pointer to BDOS entry

  if UZI280

FIRST3::
; For UZI, this program is already patched to contain the program
; (with the first three bytes patched)
;
; original instruction of patched program at address 100-103h
; and jump into CP/M transient program just loaded
;	jp	04b0H	; zde13
	jp	0103h	; Hitech C
;	ex	de,hl
;	jp	0162h	; slr asm
;	jp	20e2h	; turbo pascal
;	jp	20c4h	; multiplan
;	jp	5d71h	; mbasic
  endif ;UZI280

  if RSX280
	; Program loaded - off we go!
	ld	hl,done		; Push a return address
	push	hl		; to return to the CPM X> prompt
	jp	tpa		; Start transient program

;*******************************************************************
; Detach console terminal
DETACH: ld	hl,IO.DET	; Change function code to detach
	ld	(attqio+Q.FUNC),hl
	; fall through

; Attach console terminal with ASTs
ATTACH:	ld	hl,attqio
	SC	.QIO		; .QIOW
	ret	c		; if queuing failed
	ld	a,(QIOSB)	; fetch return code
	or	a		; clear carry
	ret	z
	scf
	ret

;*******************************************************************
; Unsolicited character input AST routine
TTAST:	ex	(sp),hl		; fetch character from stack, save HL
	push	de
	push	bc
	push	ix
	ld	ix,TTQ
	ld	c,l		; get char into reg C for qput
	ld	a,c
	cp	03h		; ^C ?
	jr	nz,ast1
	ld	hl,CCFLG	; Check Ctrl-C flag
	ld	a,(hl)
	or	a
	call	z,qinit		; clear input queue if yes
	inc	hl
	set	7,(hl)		; set ^C flag
ast1:	call	qput		; store char in queue
	ld	e,TIEFN
	SC	.SETF		; set event flag
	pop	ix
	pop	bc
	pop	de
	pop	hl
	SC	.ASTX		; exit AST

;*******************************************************************
; Get argv[] and argc
;
; On entry: IX -> array of 10 argv pointers
;	    HL -> command string
;
; Returns:  argc in HL
;
getargs:
	push	ix
	push	hl
	ld	hl,NULL
	ld	b,10		; set argv[0..9] to NULL
arg_z:	ldw	(ix+0),hl
	inc	ix
	inc	ix
	djnz	arg_z
	pop	hl
	pop	ix

	ldw	(ix+0),hl	; save argv[0] (program name)
	ld	c,1		; for computing argc

arg_0:	ld	a,(hl)		; scan for white-space
	or	a
	jr	z,arg_2		; empty string
	cp	CR
	jr	z,arg_1a	; CR
	cp	' '
	jr	z,arg_1		; a space found
	inc	hl
	jr	arg_0

arg_1:	ld	(hl),0		; replace the space with a NUL
	inc	hl
	inc	ix
	inc	ix
	ldw	(ix+0),hl	; save next argv pointer
	inc	c		; bump argc
	ld	a,c
	cp	9		; Only room for argv[0..9]
	jr	c,arg_0

arg_1b:	ld	a,(hl)		; Look for CR
	or	a
	jr	z,arg_2
	cp	CR
	jr	z,arg_1a
	inc	hl
	jr	arg_1b

arg_1a:	ld	(hl),0

arg_2:	ld	ix,p_argv	; IX points to argv[0]
	ld	d,0		; DE is argc
	ld	e,c

    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'<argv>',CR,LF,0
	ldw	hl,(ix+0)
arg_3:
	call	$PRINT
	defb	'"',0
	call	$MSGHL
	call	$PRINT
	defb	'"',CR,LF,0
	ld	a,c
	or	a
	jr	z,arg_4
	dec	c
	inc	ix
	inc	ix
	jr	arg_3
arg_4:
	call	$PRINT
	defb	CR,LF,'argc = ',0
	ld	h,d
	ld	l,e
	call	$HLHEX
	call	$CRLF
    endif ;DEBUG

	ex	de,hl		; return argc value
	ret

;*******************************************************************
; Check if any character is available in the console buffer
;
; Returns zero in A if none available
;

$TTGST:	call	$FLUSH
	push	ix
	ld	ix,TTQ
	ld	a,(ix+TQ.OP)
	cp	(ix+TQ.IP)
	pop	ix
	ret

;*******************************************************************
; Single-character input, no echo

$TTGC:	call	$FLUSH		; send pending output to terminal
	push	ix
	push	hl
	push	de
	push	bc
ci1:	ld	e,TIEFN
	SC	.CLEF		; clear event flag
	ld	ix,TTQ
	call	qget		; get char from input queue
	jr	nc,ci2
	ld	e,TIEFN		; if none ready
;;	SC	.WTSE		;  then wait
	SC	.STSE
	jr	ci1
ci2:	ld	hl,ttlc
	bit	0,(hl)		; translate lowercase to uppercase?
	call	z,UCASE		; convert character if yes
	pop	bc
	pop	de
	pop	hl
	pop	ix
	ret

;*******************************************************************
; Reset terminal input queue
qinit:	xor	a
	ld	(ix+TQ.IP),a
	ld	(ix+TQ.OP),a

	ret

;*******************************************************************
; Fetch character from queue
qget:	ld	a,(ix+TQ.OP)
	cp	(ix+TQ.IP)
	scf
	ret	z		; return if buffer empty
	ld	e,a
	inc	a
	and	3Fh
	ld	(ix+TQ.OP),a
	ld	d,0
	push	ix
	add	ix,de
	ld	a,(ix+TQ.BUF)	; get char
	pop	ix
	or	a
	ret

;*******************************************************************
; Store character in queue
qput:	ld	a,(ix+TQ.IP)
	ld	e,a
	inc	a
	and	3Fh
	cp	(ix+TQ.OP)
	scf
	ret	z		; return if buffer full
	ld	(ix+TQ.IP),a
	ld	d,0
	push	ix
	add	ix,de
	ld	(ix+TQ.BUF),c	; store char
	pop	ix
	or	a
	ret

;*******************************************************************
; Flush (discard) input buffer
$FLINP: push	ix
	push	hl

	ld	ix,TTQ
	call	qinit		; reset terminal input queue

	ld	hl,ttibuf

;	ld	(hl),ttibsz	; clear buffer
;ZSM4 generates P errors if the above line is used
	ld	(hl),126
	inc	hl
	ld	(hl),1
	inc	hl
	ld	(hl),EOF
	ld	(ttiptr),hl	; clear input line
	inc	hl
	ld	(hl),0

	pop	hl
	pop	ix
	ret

;*******************************************************************
; Character output (buffered)
$TTOUT: push	hl
	ld	hl,(ttoptr)
	ld	(hl),a		; store char in buffer
	inc	hl		; advance pointer
	ld	(ttoptr),hl
	pop	hl
	push	bc
	ld	c,a
	ld	a,(ttocnt)
	inc	a		; increase byte counter
	ld	(ttocnt),a
	cp	128		; buffer full?
	ld	a,c
	pop	bc
	jr	nc,$FLUSH	; output it if yes
	cp	LF ;CR		; CR?
	ret	nz		; return if not, else flush buffer

;*******************************************************************
; Flush any queued output to console
$FLUSH: ld	a,(ttocnt)
	or	a		; check in case the function is called
	ret	z		; separately
	push	bc
	push	de
	push	hl
snd0:	xor	a
	ld	(ttoqio+Q.SUBF),a
	ld	hl,(ttocnt)	; bytes to write
	ld	h,a
	ld	(ttoqio+Q.LEN),hl
	ld	hl,0
	ld	(QIOSB+2),hl	; clear counter of bytes sent
	ld	hl,ttoqio
	SC	.QIO		; .QIOW
	ld	hl,(QIOSB+2)	; fetch byte count
	ld	a,h
	or	l		; anything sent?
	jr	z,snd0		; keep trying if not
	ld	a,(ttocnt)
	sub	l		; all bytes sent?
	ld	(ttocnt),a
	ld	de,ttobuf
	jr	z,snd1		; return if yes
	ld	c,a		; else prepare counter of bytes to move
	ld	b,0
	ld	h,b		; just in case
	add	hl,de		; HL = src (ttobuf+sent), DE = dst (ttobuf)
	ldir			; shift buffer, we'll send the remainder later
snd1:	ld	(ttoptr),de	; set new buffer pointer (ttobuf+diff)
	pop	hl
	pop	de
	pop	bc
	ret

;*******************************************************************
TTCLR:	push	hl
	ld	hl,ttobuf
	ld	(ttoptr),hl
	xor	a
	ld	(ttocnt),a
	pop	hl
	ret

;*******************************************************************
;Newline
$CRLF:	call	$PRINT
	defb	CR,LF,0
	ret

;Print in-line message terminated by a NUL
$PRINT:
	ex	(sp),hl
	call	$MSGHL
	ex	(sp),hl
	ret

;Print message pointed to by HL terminated by a NUL
$MSGHL:	ld	a,(hl)
	inc	hl
	or	a
	ret	z
	call	$TTOUT
	jr	$MSGHL

    if DEBUG

$HLHEX:	ld	a,h
	call	$AHEX
	ld	a,l
$AHEX:	push	af
	rrca
	rrca
	rrca
	rrca
	call	$CHEX
	pop	af
$CHEX:	and	0Fh
	add	a,90h
	daa
	adc	a,40h
	daa
	jp	$TTOUT

      if 0
dumppg0:
	call	$PRINT
	defb	CR,LF,'<page0>',0
	ld	hl,0
du_p0:	ld	a,l
	and	0Fh
	jr	nz,du_p1
	call	$CRLF
	call	$HLHEX
	call	$PRINT
	defb	': ',0
du_p1:	ld	a,(hl)
	call	$AHEX
	call	$PRINT
	defb	' ',0
	inc	hl
	cpw	hl,0100h
	jr	nz,du_p0
	jp	$CRLF
      endif

      if 0
dumptpa:
	call	$PRINT
	defb	CR,LF,'<tpa>',0
	ld	hl,tpa
du_t0:	ld	a,l
	and	0Fh
	jr	nz,du_t1
	call	$CRLF
	call	$HLHEX
	call	$PRINT
	defb	': ',0
du_t1:	ld	a,(hl)
	call	$AHEX
	call	$PRINT
	defb	' ',0
	inc	hl
	cpw	hl,(topcom)
	jr	nz,du_t0
	jp	$CRLF
      endif

      if 0
; Dump out the FSR and FDB in hex.  IX points to FSR
;
dumpfsr:
	push	hl
	push	bc
	call	$PRINT
	defb	CR,LF,'<FDB>',CR,LF,0
	ldw	hl,(ix+FC.FDB)
	call	$HLHEX
	call	$PRINT
	defb	': ',0
	ld	b,FINFSZ
du_0:   ld	a,(hl)
	call	$AHEX
	ld	a,' '
	call	$TTOUT
	inc	hl
	ld	a,b
	and	0Fh
	jr	nz,du_1
	call	$CRLF
	call	$HLHEX
	call	$PRINT
	defb	': ',0
du_1:
	djnz	du_0
	call	$PRINT
	defb	CR,LF,'<FSR>',CR,LF,0
	push	ix
	pop	hl
	call	$HLHEX
	call	$PRINT
	defb	': ',0
	ld	b,FCSIZ
du_2:	ld	a,(hl)
	call	$AHEX
	ld	a,' '
	call	$TTOUT
	inc	hl
	djnz	du_2
	call	$CRLF
	pop	bc
	pop	hl
	ret
      endif ;0

    endif ;DEBUG

;*******************************************************************
; Exit program
$EXITC:	call	$CRLF
$EXIT:	call	$FLINP		; flush input buffer
	ld	c,LUNTI
	call	DETACH
	ld	hl,EX.SUC	; Exit to monitor with success
	SC	.EXIT
	halt			; We should never get here

  endif ;RSX280

;*******************************************************************
  if UZI280
;
;   Use system calls for UZI280 (unix edition 7)
;
; _exit(int val)
_exit:
	SC 0
	jr	DISP
; open(char *name,int flag)
_open:
	SC 1
	jr	DISP
; close(int index)
_close:
	SC 2
	jr	DISP
; creat(char *name,int mode)
_creat:
	SC 3
	jr	DISP
; unlink(char *path)
_unlink:
	SC 6
	jr	DISP
; read(int d, char *buf,unsigned nbytes)
_read:
	SC 7
	jr	DISP
; write(int d, char *buf,unsigned nbytes)
_write:
	SC 8
	jr	DISP
; 16 bit seek.
; seek(int file,offset,flag)
_seek:
	SC 9
	jr	DISP
; execve(char *name,*argv[],*envp[])
_execve:
	SC 23
	jr	DISP
; wait(int *statloc)
_wait:
	SC 24
	jr	DISP
; ioctl(int fd,request,char *data
_ioctl:
	SC 29
	jr	DISP
; fork()
_fork:
	SC 32
DISP:	ret	nc		; no error
	ld	(errno),hl
	ld	hl,-1
	ret

  endif ;UZI280

;*******************************************************************
  if RSX280

; int open(char *name,int flag)
;
; Open a file with the given "name" and access mode flag
;
; Parameters passed on the stack
;
; Returns the LUN of the open file in HL (or -1 on error)
;
_open:
    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%OPEN-I-Filename "',0
	ldw	hl,(sp+4)
	call	$MSGHL
	call	$PRINT
	defb	'" mode ',0
	ldw	hl,(sp+2)
	call	$HLHEX
    endif ;DEBUG

	ld	hl,luntb	; look for an available LUN
	ld	bc,1
op_0:	bit	0,(hl)
	jr	z,op_1		; found LUN in BC is free
	inc	hl
	inc	c
	ld	a,c
	cp	luntbsz+1
	jr	c,op_0

    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%OPEN-F-No free LUN',0
    endif ;DEBUG
	ld	a,E.NOBUF	; Use "Out of disk buffers" error
	jp	op_err

op_1:	ld	(opnltbe),hl	; Save in case open fails
	set	0,(hl)		; Mark this lun as unavailable
	; LUN is in BC
	ld	(opnlun),bc	; Save it

    if 0 ;DEBUG
	push	bc
	call	$PRINT
	defb	CR,LF,'%OPEN-I-Using LUN ',0
	ld	h,b
	ld	l,c
	call	$HLHEX
	pop	bc
    endif ;DEBUG

	ld	de,FCSIZ+512	; size of FSR and buffer
	ld	hl,fsr_1	; Which file storage region to use?

op_2:	dec	bc		; index by LUN-1
	ld	a,c
	or	a
	jr	z,op_3
	add	hl,de
	jr	op_2

op_3:	push	hl
	pop	ix
	; IX points to the file storage region for this LUN
  if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%OPEN-I-FSR address ',0
	push	ix
	pop	hl
	call	$HLHEX
	call	dumpfsr
  endif ;DEBUG
	ldw	hl,(sp+2)	; get flag to HL
	ld	(ix+FC.MODE),L	; set file access mode bit

	ldw	hl,(sp+4)	; point HL to name string
	push	ix
	ldw	ix,(ix+FC.FDB)  ; point IX to FCB
	call	PFN		; parse name into fcb
	pop	ix
	jr	nc,op_4		; It parsed correctly

    if 0 ;DEBUG
	push	af
	call	$PRINT
	defb	CR,LF,'%OPEN-F-Parse filename failed',0
	pop	af
    endif ;DEBUG
	jr	op_err		; illegal filename

op_4:
    if 0 ;DEBUG
	call	dumpfsr
    endif ;DEBUG

	ldw	hl,(sp+2)	; is it an open for Read?
	ld	a,l
	bit	FM.RD,a		;  (or Read/Write)
	jr	nz,op_5		; yes, open existing file

	and	NOT (1 SHL FM.WR) ; Are there other mode bits (other than WR)
	jr	z,op_creat
	ld	a,E.BADOP	; We don't support them for now.
	jr	op_err

op_creat:
    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%OPEN-I-Creating new file',0
    endif ;DEBUG

	xor	a		; non-contiguous (A=0)
	ld	c,a		; number of blocks to
	ld	d,a		;  allocate (CDE=0)
	ld	e,a

	call	FCREAT		; create a new file
	jr	op_6

op_5:
    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%OPEN-I-Existing file',0
    endif ;DEBUG

	call	FOPEN		; open existing file
op_6:	jp	c,op_err

    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%OPEN-I-File opened',CR,LF,0
    endif ;DEBUG

	ld	hl,(opnlun)	; return the LUN of opened file
	or	a		; clear carry
	ret

op_err:	ld	l,a		; save RSX280 error in errno
	ld	h,0
	ld	(errno),hl
    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%OPEN-E-Failed. Error code ',0
	call	$HLHEX
    endif ;DEBUG
	ld	hl,(opnltbe)	; open failed - reset LUN
	res	0,(hl)		;  in-use entry
	ld	hl,-1
	scf
	ret

; close(int index)
;
; Close the opened file with the LUN given by index
;
_close:
    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%CLOSE-I-Close LUN ',0
	ldw	hl,(sp+2)
	call	$HLHEX
	call	$CRLF
    endif ;DEBUG

	ldw	hl,(sp+2)
	call	checklun
	jr	nc,cl_err

	ld	(opnlun),hl
	ld	b,h
	ld	c,l
	ld	de,FCSIZ+512
	ld	hl,fsr_1	; Which file storage region to use?

cl_2:	dec	bc		; index by LUN-1
	ld	a,c
	or	a
	jr	z,cl_3
	add	hl,de
	jr	cl_2

cl_3:	push	hl
	pop	ix
	; IX points to the file storage region for this LUN
	call	FCLOSE		; close it
	push	af		; save status

	ld	de,(opnlun)
	dec	de
	ld	hl,luntb
	add	hl,de
	res	0,(hl)		; Mark this LUN as available

	pop	af
	ret	nc		; No errors

	ld	l,a		; Error code from FCLOSE
	ld	h,0

cl_err:
    if 0 ;DEBUG
	push	af
	call	$PRINT
	defb	CR,LF,'%CLOSE-E-Error closing file',0
	pop	af
    endif ;DEBUG

	ld	(errno),hl
	ld	hl,-1
	ret

; Check the LUN in HL is valid
; return Carry Set if it is
; Return Carry clear if not and error code in HL
;
checklun:
	ld	a,h
	or	l
	jp	z,lun_err	; LUN cannot be zero
	cpw	hl,luntbsz+1
	ret	c
lun_err:
	ld	hl,E.INV	; LUN > maximum allowed
	ret

; creat(char *name,int mode)
_creat:
    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%CREAT-I-Create file "',0
	ldw	hl,(sp+4)
	call	$MSGHL
	call	$PRINT
	defb	'" prot ',0
	ldw	hl,(sp+2)
	call	$HLHEX
    endif ;DEBUG

	; We'll ignore the protection mask and just call _open
	ldw	hl,(sp+4)
	push	hl
	push	flag_w		; Open for Write will create
	call	_open		;  a new file (a new version)
	pop	de
	pop	de
	; Return the staus from _open
	ret

; unlink(char *path)
_unlink:
;**TODO
    if DEBUG
	call	$PRINT
	defb	CR,LF,'%UNLINK-E-Not yet implemented',0
	scf
    endif ;DEBUG
	ret	nc
	ld	(errno),hl
	ld	hl,-1
	ret

; read(int d, char *buf,unsigned nbytes)
_read:

    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%READ-I-Read from LUN ',0
	ldw	hl,(sp+6)
	call	$HLHEX
	call	$PRINT
	defb	' into ',0
	ldw	hl,(sp+4)
	call	$HLHEX
	call	$PRINT
	defb	' bytes ',0
	ldw	hl,(sp+2)
	call	$HLHEX
	call	$CRLF
    endif ;DEBUG

	ldw	ix,(sp+4)	; point to buffer
	ldw	hl,(sp+6)	; d

rd_0:	; read from a file - buf ptr is in IX
        ld	b,h		; LUN -> BC
	ld	c,l
	ld	de,FCSIZ+512	; Select FSR for this LUN
	ld	hl,fsr_1

rd_2:	dec	bc
	ld	a,c
	or	a
	jr	z,rd_3
	add	hl,de
	jr	rd_2

rd_3:	push	ix		; juggle registers
	ex	(sp),hl		; buf ptr in HL, fsr ptr on stack
	pop	ix		; fsr in IX
	ex	de,hl		; buf ptr in DE
	ldw	hl,(sp+2)	; number of bytes
	ld	b,h		;  into BC
	ld	c,l
        ; all set, now do the read
	call	FREAD
	; number of bytes read is returned in BC, CY set on error
	ret	nc		; done
	ld	h,0
	ld	l,a
	ld	(errno),hl	; put error code into errno
	ld	hl,-1
	scf
	ret

; write(int d, char *buf,unsigned nbytes)
_write:

    if 0 ;DEBUG
	call	$PRINT
	defb	CR,LF,'%WRITE-I-Write to LUN ',0
	ldw	hl,(sp+6)
	call	$HLHEX
	call	$PRINT
	defb	' from ',0
	ldw	hl,(sp+4)
	call	$HLHEX
	call	$PRINT
	defb	' bytes ',0
	ldw	hl,(sp+2)
	call	$HLHEX
	call	$CRLF
    endif ;DEBUG

	ldw	ix,(sp+4)	; point to buffer
	ldw	hl,(sp+6)	; d
	call	checklun
	jr	nc,wr_err	; Invalid LUN

        ld	b,h		; LUN -> BC
	ld	c,l
	ld	de,FCSIZ+512	; Select FSR for this LUN
	ld	hl,fsr_1

wr_2:	dec	bc
	ld	a,c
	or	a
	jr	z,wr_3
	add	hl,de
	jr	wr_2

wr_3:	push	ix		; juggle registers
	ex	(sp),hl		; buf ptr in HL, fsr ptr on stack
	pop	ix		; fsr in IX
	ex	de,hl		; buf ptr in DE
	ldw	hl,(sp+2)	; number of bytes
	ld	b,h		;  into BC
	ld	c,l
        ; all set, now do the write
	call	FWRITE
	; number of bytes written is returned in BC, CY set on error
	ret	nc		; done
	ld	h,0
	ld	l,a
wr_err:	ld	(errno),hl	; put error code into errno
	ld	hl,-1
	scf
	ret

; 16 bit seek.
; seek(int file,offset,flag)
_seek:

;**TODO
    if DEBUG
	call	$PRINT
	defb	CR,LF,'%SEEK-E-Not yet implemented',0
	scf
    endif ;DEBUG
	ret	nc
	ld	(errno),hl
	ld	hl,-1
	ret

  endif ;RSX280

;*******************************************************************
; The following BIOS routines are located in
; the BDOS area to maximise available memory

; BIOS console input
_conin:
	call	readchar
;	if (arg == '\n')
;	    arg = '\r';
	ld	a,(char)
	cp	LF		;'\n'
	ret	nz
	ld	a,CR		;'\r'
	ret

; BIOS console output
_conout:
	ld	a,c
	ld	(char),a
	jp	writechar


; BIOS console input status
_conist:
	call	char_avail
	ld	a,h
	or	l
	ret	z		; no char available
	ld	a,0ffh
	ret

; Dummy routine for unsupported BIOS calls
dummy:
  if UZI280
; write(2,"Illegal BIOS call\n",18);
	push	stderr
	push	biosmsg
	push	biosml		; length of message
	call	_write
	pop	de
	pop	de
	pop	de
; 	fall through
  endif ;UZI280

  if RSX280
	ld	hl,biosmsg
	call	$MSGHL
  endif ;RSX280

; end of program run

done:
  if UZI280
	; UZI exits to command shell
	ld	hl,(080h)	; HI-TECH C stores its exit value at 80h
	push	hl
	call	_exit
  endif ;UZI280

  if RSX280
	;RSX prompts for next CP/M program
	ld	sp,tmpstk	; back to our stack

    if DEBUG
	call	$PRINT
	defb	CR,LF,'%CPM-I-Program exit',CR,LF,0
    endif ;DEBUG

	; Close any open files
	ld	hl,luntb
	ld	de,1		; start with LUN 1
do_1:	bit	0,(hl)		; is it open?
	jr	z,do_2		; no
	push	hl
	push	de		; LUN
	call	_close		; close it
	pop	de
	pop	hl
	res	0,(hl)		; mark it as closed
do_2:	inc	hl
	inc	de		; next LUN
	ld	a,e
	cp	luntbsz+1	; are we done ?
	jr	c,do_1		; no

	xor	a
	ld	(ttlc),a	; Uppercase enable
	ldw	(CCFLG),0	; Re-enable Ctrl-C processing
	jp	reentry		; Go and get next emulator command
  endif ; RSX280

;*******************************************************************
  if UZI280

	dseg			; only UZI is using DSEG for now

; additional search path for file open
SRCHPATH:	defb	"/sys/lib/HiTech/",0
;SRCHPATH:	defb	"/CPM/bin/",0

; strings used for execve call
shell:	defb	"/bin/sh",0
shell1:	defb	"sh",0
shell2:	defb	"-c",0

argv:	defw	shell1		; "sh"
	defw	shell2		; "-c"
	defw	p_name		; "mv oldname newname"
	defw	0		; end of argv

  endif ;UZI280

  if UZI280

u_name:	defs	16		; holds converted uzi file name
p_name:	defs	40		; file name for path search and execve()
environ:	defs	2

  endif ;UZI280

; CP/M BDOS emulator variables

biosmsg:	defb	"Illegal BIOS call",LF,0
biosml	equ	$-biosmsg-1

oldstk:	defs	2
arg:	defs	2
call:	defs	2
dmaadr:	defs	2
char:	defs	2
errno:	defs	2

  if RSX280

	cseg

VERSION: defb	'V0.99'
  if DEBUG
	defb	' [DEBUG]'
  endif ;DEBUG
	defb	CR,LF,'Use ^Z followed by Return/Enter to exit.'
	defb	CR,LF,0

argc:	defs	2
p_argv:	defs	10*2		; Room for 10 pointers (0..9)

NULL:	defb	0

COMFCB:	defs	FNSZ		; RSX280 filespec of CP/M .COM file

DOTCOM:	defb	'.COM',0
topcom:	defs	2

u_name:	defs	16		; holds converted RSX file name

; QIO commands for console terminal
IO.ATA	equ	IO.ATT OR (TF.AST SHL 8)	; attach with AST
;
attqio:	QIOW$	IO.ATA,LUNTI,TOEFN,QIOSB,,<TTAST>	; attach console
ttoqio:	QIOW$	IO.WVB,LUNTI,TOEFN,QIOSB,,<ttobuf,,,,0>	; console output

; QIO status
QIOSB:	defs	4

luntbsz	equ	4
luntb:	defs	luntbsz		; LUN "in-use" table
				; One byte for each LUN 1-4
				; Non-zero means file open
opnltbe: defs	2		; Current luntb entry
opnlun:	defs	2		; The LUN being accessed

; Console terminal input queue
TTQ:	defs	1		;input position
	defs	1		;output position
	defs	64		;buffer

ttlc:	defs	1		;lowercase input flag

; Console input line
ttibsz	equ	126
ttiptr:	defw	ttibuf		; pointer to buffer
ttibuf:	defb	ttibsz		; first byte has size
	defb	0		; number of characters in buffer
	defs	ttibsz		; the line buffer

; Console output line
glbpsv:	defs	2
ttocnt:	defb	0		;output count
ttoptr:	defw	ttobuf		;output pointer
ttobuf:	defs	128		;buffer

CCFLG:	defs	2		;ctrl-C break flag

; BDOS console storage (RDBUF)
outflag:
	defb	0		; output flag (non zero means no output)
starting:
	defb	2		; starting position for cursor
curpos:	defb	0		; cursor position (0=start of line)


  endif ;RSX280

; Stack
  if RSX280

	cseg

    if (($-tpa) and 1)	; Even address boundary
	defs	1
    endif

	defs	256
  endif
  if UZI280

	dseg

	defs	30
  endif

tmpstk:

;*******************************************************************
; CP/M File Control Block offsets

;struct	fcb {
;/*0*/	char	drive;		/* drive code */
;/*1*/	char	name[8];	/* file name */
;/*9*/	char	ext[3];		/* file type */
;/*12*/	char	ex;		/* file extent */
;/*13*/	int	magic;		/* UZI280/RSX280 open file magic number */
;/*15*/	char	rec;		/* number of records in present extent */
;/*16*/	char	desc;		/* UZI280 file number/RSX280 LUN */
;/*17*/	char	dm[15];		/* CP/M disk map */
;/*32*/	char	nr;		/* next record to read or write */
;/*33*/	unsigned ranrec;	/* random record number (24 bit no. ) */
;/*35*/	char	hr_rec;		/*   "       "   high byte */
;};
fcbname	equ	1
fcbext	equ	9
fcbmagic equ	13
fcbdesc	equ	16
fcbrec	equ	20		; internal record counter read/write.
fcbran	equ	33

; magic number of open file
; (emulator writes this to S1 and S2 bytes in a CP/M FCB when a file is open)
MAGIC		equ	12345

; BDOS function dispatch table (keep this in cseg)
	cseg

bdostable:
	defw	done		; 0 - system reset
	defw	read_console	; 1 - console read
	defw	write_console	; 2 - console write
	defw	no_good		; 3 - reader input
	defw	no_good		; 4 - punch output
	defw	no_good		; 5 - list output
	defw	direct_console	; 6 - direct console I/O
	defw	no_good		; 7 - get IO byte
	defw	no_good		; 8 - set IO byte
	defw	print_string	; 9 - print string
	defw	rdbuf		; 10 - read console buffer
	defw	console_status	; 11 - get console status
	defw	return_version	; 12 - get version
	defw	reset_dma	; 13 - reset disk system
	defw	ret_0		; 14 - select disk
	defw	openfile 	; 15 - open file
	defw	closefile 	; 16 - close file
	defw	no_good		; 17 - search for first file
	defw	no_good		; 18 - search for next file
	defw	delete		; 19 - delete file
	defw	readfile	; 20 - read next record
	defw	writefile	; 21 - write next record
	defw	makefile	; 22 - create file
	defw	rename		; 23 - rename file
	defw	ret_1		; 24 - get login vector
	defw	ret_0		; 25 - get current disk
	defw	set_dma		; 26 - set disk DMA address
	defw	no_good		; 27 - get allocation vector
	defw	no_good		; 28 - write protect disk
	defw	no_good		; 29 - get read-only vector
	defw	no_good		; 30 - set file attributes
	defw	no_good		; 31 - get addr(dpb params)
	defw	ret_0		; 32 - set/get user code
	defw	readrandom	; 33 - read random
	defw	writerandom	; 34 - write random
	defw	no_good		; 35 - compute file size
	defw	setrandom	; 36 - set random record
	defw	reset_dma 	; 37 - reset drive
	defw	writerandom	; 38 - write random with zero fill
; end of BDOS dispatch table

maxbdosfn equ	(($-bdostable)/2)-1 ; should be 38 (026h)

	page
;
; First try of a direct bios call implementation
;
	cseg

tobios	equ	(cpmbios-cpmtpa)-($-tpa)
  if tobios and 8000h	; negative (sign bit on)
    if2
	.printx /ERROR: BDOS area overflowed into BIOS area/
    endif
  else
	defs	tobios
  endif

;*******************************************************************
; The BIOS jump table.
; Routines are located above to minimise
; what would otherwise be wasted memory space.

bios::	jp	done		;0 Cold Boot
	jp	done		;1 Warm Boot
	jp	_conist		;2 Console Input Status
	jp	_conin		;3 Console Input
	jp	_conout		;4 Console Output
	jp	dummy		;5 List Output
	jp	dummy		;6 Punch Output
	jp	dummy		;7 Reader Input
	jp	dummy		;8 Home
	jp	dummy		;9 Select Disk
	jp	dummy		;10 Set Track
	jp	dummy		;11 Set Sector
	jp	dummy		;12 Set DMA Transfer Address
	jp	dummy		;13 Read Sector
	jp	dummy		;14 Write Sector
	jp	dummy		;15 List Output Status
	jp	dummy		;16 Sector Translate

  if RSX280

; We use FCS to access files.  These are the File Storage Regions for
; each of the LUNs that are used (only 4 at present)

; Note: The file access mode bits are overwritten by the _open
; routine and we use a common event flag for access to all files

fsr_1::	FSR$	FDB1,<1 SHL FM.RD>,LUNFL1,FIOEFN
fsr_2::	FSR$	FDB2,<1 SHL FM.WR>,LUNFL2,FIOEFN
fsr_3::	FSR$	FDB3,<1 SHL FM.WR>,LUNFL3,FIOEFN
fsr_4::	FSR$	FDB4,<1 SHL FM.WR>,LUNFL4,FIOEFN

FDB1::	defs	FINFSZ
FDB2::	defs	FINFSZ
FDB3::	defs	FINFSZ
FDB4::	defs	FINFSZ


  endif ;RSX280

	end
