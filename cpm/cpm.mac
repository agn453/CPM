	title	CP/M 2.2 Emulator for RSX280
	ident	"V0.99"		; pre-release version

;*******************************************************************
;
;	CPM - CP/M 2.2 BDOS/BIOS emulation for RSX280.
;
;	Copyright (C) 2020, Tony Nicholson
;
;  This program is free software; you can redistribute it and/or
;  modify it under the terms of the GNU General Public License as
;  published by the Free Software Foundation; either version of
;  the License, or (at your option) any later version.
;
;  This program is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this program; if not, write to the Free Software
;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
;
;*******************************************************************
;
;  Acknowledgements
;
;  Loosely based on CPMEMU - a CP/M emulator for the UZI-280
;  operating system by Stefan Nitschke and released into the
;  Public Domain on 13-Mar-1996.
;
;  Also, portions of the original CP/M 2.2 BDOS and CCP
;  source code by Digital Research Inc. have been adapted to
;  preserve the functions of various routines in this
;  emulation.
;
;  CP/M is Copyright (C) Caldera Corporation and later by Lineo Inc.
;
;  Original source-code, disassembled sources and documentation
;  for CP/M are available from the "Unofficial CP/M Web Site" for
;  hobbyists, developers and the retro-computing community at
;
;	 http://www.cpm.z80.de
;
;*******************************************************************

	.Z280

FALSE	equ	0
TRUE	equ	not FALSE

DBG_CON equ	0001h		; console I/O debug
DBG_FIO equ	0002h		; file read/write debug
DBG_SRH	equ	0004h		; search first/next debug
DBG_SEL	equ	0008h		; disk selection
DBG_ERR equ	8000h		; error debug

DEBUG	equ	DBG_ERR or DBG_SEL ;or DBG_SRH

;
; Include files and externals

	; uses FCS routines for RSX280 file access
	extrn	FCREAT,FOPEN,FCLOSE
	extrn	FREAD,FWRITE,FSEEK
	extrn	PFN,FREN,FDEL

	; RSX280 definitions (list off)
	list	off
  ifdef ZXCC
	; cross-compile with include files in current directory
	include SYSFN.INC
	include	QIO.INC
	include FCB.INC
	include	DCB.INC
	include	TCB.INC
	include	FCSLIB.INC
	include	ERRORS.INC
  else
	; native RSX280 has include files in LB:[SYSTEM]
	include $SYSFN.INC
	include	$QIO.INC
	include $FCB.INC
	include	$DCB.INC
	include	$TCB.INC
	include	$FCSLIB.INC
	include	$ERRORS.INC
  endif ;ZXCC
	list	on

; Control Characters
ETX	equ	03h
BS	equ	08h
CR	equ	0Dh
LF	equ	0Ah
FF	equ	0Ch
TAB	equ	09h
CTRLZ	equ	1Ah
RUBOUT	equ	7Fh

;*******************************************************************
; CP/M memory sizing
; (consult the TKB map file before changing this)
;
memsize	equ	57		; 58KB memory size
topmem	equ	memsize*1024
cpmoffs	equ	topmem-20*1024	; based on standard CP/M 2.2

; Where CP/M expects things to be
cpmwarm	equ	00000h		; warm boot jump
cpmiob	equ	00003h		; I/O byte
cpmddr	equ	00004h		; default drive
cpmentry equ	00005h		; BDOS jump vector
cpmfcb1	equ	0005ch		; FCB 1
cpmfcb2	equ	0006ch		; FCB 2
cpmdma	equ	00080h		; default DMA address and command line
cpmtpa	equ	00100h		; transient programs are loaded here
cpmccp	equ	03400h+cpmoffs	; CCP is implemented by this program
cpmbdos	equ	03c00h+cpmoffs	; BDOS contains emulation code
cpmbios	equ	04a00h+cpmoffs	; BIOS only emulates character I/O

; CP/M File Control Block offsets
;struct	fcb {
;/*0*/	char	drive;		/* drive code */
;/*1*/	char	name[8];	/* file name */
;/*9*/	char	ext[3];		/* file type */
;/*12*/	char	ex;		/* file extent */
;/*13*/ char	s1;		/* system use s1 */
;/*14*/	char	s2;		/* system use s2 */
;/*15*/	char	rc;		/* number of records in present extent */
;/*16*/	char	dm[16];		/* Reserved for system use (disk map) */
;/*28*/	byte	lun;		/* RSX280 LUN for file when open */
;/*29*/	byte	magic;		/* RSX280 MAGIC byte to indicate file opened */
;/*30*/ int	rec;		/* RSX280 internal 16-bit record count */
;/*32*/	char	cr;		/* current record to read or write */
;/*33*/	unsigned ranrec;	/* random record number (24 bit no. ) */
;/*35*/	char	hr_rec;		/*   "       "   high byte */
;}
fcbdrive equ	0		; drive code
fcbname	equ	1		; file name
fcbext	equ	9		; file type (extension)
fcbex	equ	12		; file extent
fcbs1	equ	13		; s1
fcbubytes equ	fcbs1		; s1 used for unfilled bytes field
fcbs2	equ	14		; s2
fcbmodnum equ	fcbs2		; s2 used for module number
fcbrc	equ	15		; record count
fcbdm0	equ	16		; disk allocation map
fcbcr	equ	32		; current CP/M record
fcbran	equ	33		; random access record number
fcbranh	equ	35		; random access record high byte (24-bit)

fcbnamlen equ	15		; name length for search matching
fcblen	equ	36		; length of CP/M FCB

fcblun	equ	28		; file LUN
fcbmagic equ	29		; set to magic number if file open
fcbrec	equ	30		; RSX280 record counter read/write word

DE.NAME9 equ	DE.NAME+8	; offset for 9th character of filename

empty	equ	0E5h		; deleted or empty directory entry
recsiz	equ	128		; record size (CP/M sector size)
maxdir	equ	1024		; number of directory entries
dirlen	equ	32		; directory entry length (CP/M)
dirspr	equ	recsiz/dirlen	; directory entries per sector
dskmsk	equ	dirspr-1	; mask for directory entry
maxext	equ	31		; maximum extent value
dircnt	equ	maxdir/dirspr	; number of directory sectors

; magic number of open file
;
; The emulator writes this to s2 byte in a CP/M FCB when a file is open
; (along withe the LUN of the open file in the s1 byte).
MAGIC	equ	05Eh

; RSX280 Logical Unit Numbers
LUN_F1	equ	1		; emulator file access LUN #1
LUN_F2	equ	2		; emulator file access LUN #2
LUN_F3	equ	3		; emulator file access LUN #3
LUN_F4	equ	4		; emulator file access LUN #4
LUN_TI	equ	5		; terminal LUN (TI:)
LUN_SY	equ	6		; LUN for rename/delete file
LUN_D	equ	7		; LUN for directory file
LUN_IX	equ	8		; LUN for accessing INDEXF.SYS

; Event flags
EFN_TI	equ	1		; event flag for AST terminal input
EFN_TO	equ	2		; event flag for console output
EFN_F1	equ	3		; event flag for emulation file LUN1
EFN_F2	equ	4		; event flag for emulation file LUN2
EFN_F3	equ	5		; event flag for emulation file LUN3
EFN_F4	equ	6		; event file for emulation file LUN4
EFN_SY	equ	7		; event flag for rename/delete I/O
EFN_D	equ	8		; event flag for directory file
EFN_IX	equ	9		; event flag for INDEXF.SYS

; Console terminal queue offsets
TQ.IP	equ	0		; input pointer
TQ.OP	equ	TQ.IP+1		; output pointer
TQ.BUF	equ	TQ.OP+1		; buffer

flag_r	equ	1 SHL FM.RD	; read mode for file open()
				; (opens an existing file)
flag_w	equ	1 SHL FM.WR	; write mode for file open()
				; (creates a new file verson)
flag_rw	equ	(1 SHL FM.RD) OR (1 SHL FM.WR)	; R/W mode for file open()
				; (opens an existing file)

ttibsz	equ	80		; terminal input buffer size
	page
;*******************************************************************
;
; CP/M transient program .COM files are loaded here

	cseg	; The majority of the emulator is in the code segment
tpa::
	jp	main		; command line processing

	;For RSX280 we load the CP/M .COM file into the TPA
	;region ourselves (essentially this program behaves
	;functionally like the CP/M Console Command Processor).
	;A future enhancement may be to include loading the
	;Digital Research CCP from CP/M 2.2 or one of its
	;replacements.

; One big region to load CP/M binaries into
;
	defs	cpmbdos-cpmtpa-3 ; Rest of TPA

;*******************************************************************
;
; BDOS emulator
;
; This is at the standard CP/M 2.2 address for programs
; to access. The emulator set-up and control routines
; are embedded here too. These begin at the entry-point
; labelled MAIN. When an emulated program exits, it
; either does a Warm Boot (JP 0/RST 0) or return (if the
; stack hasn't been modified) and the emulator closes any
; open files and prompts for the next CP/M command.
; To exit back to RSX280, type Ctrl-Z then Return to the
; X> prompt.
;
bdos::
	nop			; make the BDOS look like real CP/M
	nop			; (it starts with 6 NOPs)
	nop
	nop
	nop
	nop
entry:
	ld	(oldstk),sp	; save and switch stack
	ld	sp,tmpstk
	ex	de,hl
	ld	(arg),hl
	ld	a,c
	ld	(func),a 	; BDOS function number
	push	iy		; RSX280 routines use IY
	push	ix
	push	hl
	pop	iy		; (arg) also into IY
	call	bdos2
	pop	ix
	pop	iy
	ex	de,hl		; save return val in DE
	ld	sp,(oldstk)	; restore stack
	ld	hl,(arg)
	ex	de,hl		; restore orig contents of DE
	ld	a,(func)
	ld	c,a		; restore original contents of C
	ld	a,l		; get return value into A
	ld	b,h		; and B for strict compatibility
	ret

bdos2:
	cp	maxbdosfn+1
	ret	nc		; function number too big
	add	a,a
	ld	hl,bdostable	; index into table
	add	hl,a
	ld	hl,(hl)
	jp	(hl)		; go there, function just returns above

;*******************************************************************
; BDOS call return version number
return_version:
	ld	hl,022h		; pretend to be CP/M 2.2
	ret

;*******************************************************************
; BDOS call set dma address
set_dma:
	ld	hl,(arg)
	ld	(dmaadr),hl
	ret

;*******************************************************************
; BDOS call reset dma address
reset_dma:
	ld	hl,cpmdma
	ld	(dmaadr),hl
	ret

;*******************************************************************
; BDOS call console input status
console_status:
	call	char_avail
	ld	a,l
	or	h
	ret	z		; no char available
	ld	hl,0ffh
	ret

;*******************************************************************
; BDOS call write string
print_string:
	push	hl
	ld	hl,(arg)
pr_lop:	ld	a,(hl)
	cp	'$'
	jr	z,pr_done
	call	writechar
	inc	hl
	jr	pr_lop
pr_done:
	call	$FLUSH		; empty console buffer
	pop	hl
	ret

;*******************************************************************
; BDOS call direct console IO
direct_console:
	ld	a,(arg)
	cp	0ffh
	jr	nz,write_console
	call	char_avail
	ld	a,h
	or	l
	ret	z		; no char available, return zero
	call	readchar
	ld	a,(char)
	jr	rc_1

;*******************************************************************
; BDOS call write console
write_console:
	ld	a,(arg)
	ld	(char),a
	jp	writechar

;*******************************************************************
; BDOS call read console.
read_console:
	call	readchar
	ld	a,(char)
	call	echoc		; Echo character
	jr	c,rc_1		; Non-printing?
	push	af
	ld	c,a
	call	tabout
	pop	af

rc_1:	ld	l,a		; return result in A and HL
	ld	h,0
	ret

;*******************************************************************
; BDOS call read console buffer
;
; We'll use code similar to the original DRI BDOS for
; reading the console buffer (for an authentic "feel")
;
; Returns with HL pointing to number of bytes in buffer

rdbuf:	ld	a,(column)	; save cursor position
	ld	(strtcol),a	;  for processing Ctrl-X and Ctrl-H
	ld	hl,(arg)	; point HL to buffer
	ld	a,h		; is pointer NULL
	or	l
	jr	nz,rdbufg
	ld	hl,cpmdma	; yes, use default DMA buffer
rdbufg:	ld	c,(hl)		; first byte is buffer size in C
	inc	hl
	push	hl		; save pointer to available space
	ld	b,0		; number of chars input is in B
readnx:	push	bc		; save count and buf size
	push	hl		; save buf pointer
readn0:	call	conin		; get next character to A
	and	7Fh		; strip parity
	pop	hl		; restore buf pointer
	pop	bc		;  count and size
	cp	CR		; end of line?
	jp	z,readen
	cp	LF		; treat LF like a CR
	jp	z,readen
	cp	BS		; backspace?
	jr	nz,noth		; no
	ld	a,b		; yes, ignore at line beginning
	or	a
	jr	z,readnx
	dec	b		; backup one character
	ld	a,(column)
	ld	(compcol),a
	jr	linelen
noth:	cp	RUBOUT		; rubout?
	jr	nz,notrub
	ld	a,b
	or	a		; ignore at start of line
	jr	z,readnx
	ld	a,(hl)		; echo previous character
	dec	b
	dec	hl
	jr	rdech1
notrub:	cp	05h		; physical line end (Ctrl-E)?
	jr	nz,note
	push	bc
	push	hl
	call	crlf
	xor	a
	ld	(strtcol),a
	jr	readn0
	; left out the detection of Ctrl-P for printer toggle
note:	cp	18h		; cancel (Ctrl-X)?
	jr	nz,notx
	pop	hl
backx:	ld	a,(strtcol)	; backup the cursor
	ld	hl,column
	cp	(hl)
	jr	nc,rdbuf
	dec	(hl)		; move cursor back 1
	call	backsp
	jr	backx
notx:	cp	15h		; Ctrl-U (cancel line)?
	jr	nz,notu
	call	crlfp		; physical end-of-line
	pop	hl
	jp	rdbuf
notu:	cp	12h		; Ctrl-R?
	jr	nz,notr
linelen:
	push	bc		; re-type the current line
	call	crlfp
	pop	bc
	pop	hl		; HL back to beginning of line buf
	push	hl
	push	bc
rep0:
	ld	a,b
	or	a		; have we done the whole line yet?
	jr	z,rep1
	inc	hl		; no, get next character
	ld	c,(hl)
	dec	b		; count it
	push	bc
	push	hl
	call	ctlout
	pop	hl
	pop	bc
	jr	rep0
rep1:
	push	hl
	ld	a,(compcol)
	or	a
	jr	z,readn0
	ld	hl,column
	sub	(hl)
	ld	(compcol),a
back1:
	call	backsp
	ld	hl,compcol
	dec	(hl)
	jr	nz,back1
	jp	readn0
notr:
rdecho:
	inc	hl
	ld	(hl),a		; store character in buffer
	inc	b		; and count it
rdech1:
	push	bc
	push	hl
	ld	c,a
	call	ctlout
	pop	hl
	pop	bc
	ld	a,(hl)		; was it a Ctrl-C?
	cp	ETX
	ld	a,b
	jr	nz,notc
	cp	1		; only if at start of line
	jp	z,done		; exit program back to command input
notc:
	cp	c		; have we filled the buffer?
	jp	c,readnx	; no
readen:
	inc	hl		; store the line terminator in
	ld	(hl),a		;  the buffer

	pop	hl		; end the line and save the
	ld	(hl),b		;  number of characters entered

	push	hl
	ld	c,CR
	call	conout
	pop	hl
	ret

;*******************************************************************
; New line on console
crlf:
	ld	c,CR
	call	conout
	ld	c,LF
	jr	conout

; Space
space:	ld	c,' '
	jr	conout

; Backspace cursor
backsp:	call	pctlh
	call	space
pctlh:
	ld	c,BS
;	jp	conout

; fall through

;*******************************************************************
; Console output and keep track of the cursor position.
; Also does primitive flow-control using Ctrl-S.
; Character to output is in C
conout:	ld	a,(compcol)
	or	a
	jr	nz,compout	; output char and update position
	push	bc
	call	conbrk		; check for Ctrl-S
	pop	bc
	push	bc
	ld	a,c		; output character to console
	call	$TTOUT
	pop	bc
	; No printer echo (was here)
compout:
	ld	a,c		; recall character
	ld	hl,column
	cp	RUBOUT
	ret	z		; ignore NULs
	inc	(hl)		; increment column
	cp	' '
	ret	nc		; return if printable
	dec	(hl)		; decrement column
	ld	a,(hl)
	or	a
	ret	z		; return if at column 0
	ld	a,c
	cp	BS		; is it a backspace?
	jr	nz,notbacksp
	dec	(hl)		; yes, decrement column
	ret

notbacksp:
	cp	LF
	ret	nz
	ld	(hl),0		; LF resets column to 0
	ret

;*******************************************************************
; Copy parameter pointed to by IX into the CP/M FCB pointed to by HL
;
fillfcb:
	ld	(hl),0		; always the current drive
	inc	hl
	push	hl		; save and init with spaces
	ld	b,8+3
	ld	a,' '
ff_blnk:
	ld	(hl),a
	inc	hl
	djnz	ff_blnk

	pop	hl		; restore pointer to FCB

	ld	b,8		; name part is up to 8 chars
ff_nam:	ld	a,(ix+0)
	or	a		; end of string?
	ret	z
	cp	'.'		; filename delimiter
	jr	z,ff_ext
	call	delimiter	; is it a delimiter?
	ret	z		; yes - done
	cp	'*'		; wildcard?
	jr	z,ff_nwild
	ld	(hl),a		; store in FCB
	inc	ix
	inc	hl
	djnz	ff_nam
ff_skp:	ld	a,(ix+0)	; skip rest of name part
	or	a
	ret	z		; end of string - done
	cp	'.'
	jr	z,ff_exte
	call	delimiter
	ret	z		; delimiter - done
	jr	ff_skp
ff_nwild:
	ld	(hl),'?'
	inc	hl
	djnz	ff_nwild
ff_nsk:	inc	ix
	ld	a,(ix+0)	; skip until '.' or eos
	or	a
	ret	z
	cp	'.'
	jr	nz,ff_nsk
ff_ext:	inc	ix		; advance past the '.' or '*'
	ld	a,b
	or	a		; all 8 characters?
	jr	z,ff_exte
ff_adv	inc	hl
	djnz	ff_adv		; point to ext part
ff_exte:
	ld	b,3
ff_enxt:
	ld	a,(ix+0)
	or	a
	ret	z		; end of string
	call	delimiter
	ret	z
	cp	'*'		; wildcard ext?
	jr	z,ff_ewild
	ld	(hl),a
	inc	ix
	inc	hl
	djnz	ff_enxt
	ret
ff_ewild:
	ld	(hl),'?'
	inc	hl
	djnz	ff_ewild
	ret

;*******************************************************************
; BDOS call open file.
;
; On entry: IY -> pointer to FCB
;
openfile:
  if DEBUG and DBG_FIO
	call	$PSTR
	defb	'BDOS-I-Open FCB at ',0
	ld	hl,(arg)
	call	$HLHEX
  endif ;DEBUG

	; test for reopen
	ld	h,0
	ld	l,(iy+fcbmagic)
	cpw	hl,MAGIC
	jr	nz,open2
	ld	h,0
	ld	l,(iy+fcblun)
	push	hl
	call	_close		; was open
	pop	de
open2:
	call	getname		; convert to valid filename
	push	hl		; string address
	push	flag_rw
	call	_open		; open file for R/W
	pop	de
	pop	de
	cpw	hl,-1
	jr	z,no_good	; we don't do search paths for now

open_ok:
	ld	(iy+fcblun),l	; save the file number/LUB
	ld	hl,MAGIC
	ld	(iy+fcbmagic),l ; make it magic (opened)
	ld	hl,0		; return no error
	ldw	(iy+fcbrec),hl	; zero internal record count
	ld	(iy+fcbcr),l	;  and current record byte
	ret
no_good:
	ld	hl,255		; return error
	ret

;*******************************************************************
; CPM bdos call to make (create) a file
;
; On entry: IY -> pointer to FCB
;
makefile:
  if DBG_FIO and DEBUG
	call	$PSTR
	defb	'BDOS-MAKEFILE',0
	call	dumpfcb
  endif ;DEBUG

	call	getname		; convert to valid filename
	push	hl		; str adr
	call	_creat		; create the file
;    desc = creat(getname(blk), 0666);
	pop	de
	cpw	hl,-1
	jr	z,no_good

;    blk->magic= MAGIC;
;    blk->desc = desc;
;    blk->rec  = 0;
	ld	(iy+fcblun),l
	ld	hl,MAGIC
	ld	(iy+fcbmagic),l
	ld	hl,0
	ldw	(iy+fcbrec),hl
	ld	(iy+fcbcr),l
  if DBG_FIO and DEBUG
	push	hl
	call	dumpfcb
	pop	hl
  endif ;DEBUG
	ret

;*******************************************************************
; BDOS call close file
;
; On entry: IY -> pointer to FCB
;
closefile:
	ld	h,0
	ld	l,(iy+fcblun)
	push	hl
	call	_close
	pop	de
	cpw	hl,-1
	jr	z,no_good
	ld	hl,0
	ld	(iy+fcbmagic),l
	ret

;*******************************************************************
; BDOS call search first
;
; On entry: IY -> pointer to FCB
;
search_first:
  if DBG_SRH and DEBUG
	call	$PSTR
	defb	'S1st-I-FCB',0
	call	dumpfcb
  endif ;DEBUG

	ldw	(aret),0	; clear return result code

	ld	a,(diropn)	; is directory already open?
	or	a
	jr	z,sf_1		; no

	ld	ix,fsrdir	; yes, re-open it to get
	call	FCLOSE		;  any recent updates
	jr	nc,sf_1

  if DBG_FIO and DEBUG
	push	af
	call	$PSTR
	defb	'S1st-E-Close dir',0
	pop	af
  endif ;DEBUG
	jp	sf_err

sf_1:	ld	hl,cdname
	ld	c,GD.TSK	; fetch the current directory
	sc	.GDIR
	jp	c,sf_err	; some problem, return error

	ld	a,(hl)		; is there a current directory?
	or	a
	jr	nz,sf_2		; yes
	ld	hl,mdfn		; no - use master directory

sf_2:	ld	hl,cdname
	ld	de,dirname
	call	strcpy		; construct directory filename
	ld	hl,dirtype
	call	strcpy		; dirfn now contains dir file

	ld	hl,dirfn
	ld	ix,FDB_D
	call	PFN		; parse it into FDB for directory
	jp	c,sf_err

	ld	ix,fsrdir
	ld	(ix+FC.MODE),flag_r	; Read mode
	call	FOPEN		; open directory
	jr	nc,sf_4

  if DBG_FIO and DEBUG
	push	af
	call	$PSTR
	defb	'S1st-E-Open dir',0
	pop	af
  endif ;DEBUG
	jp	c,sf_err

sf_4:
	ld	a,00000001b	; mark directory file as open
	ld	(diropn),a	;  and not end of file (bit 7 off)

	ld	a,(idxopn)	; is INDEXF.SYS open?
	or	a
	jr	z,sf_6		; No

	ld	ix,fsridx	; Yes, re-open it to
	call	FCLOSE		;  refresh any updated files
	jr	nc,sf_6

  if DBG_FIO and DEBUG
	push	af
	call	$PSTR
	defb	'S1st-E-Close idx',0
	pop	af
  endif ;DEBUG
	jp	sf_err

sf_6:	ld	hl,idxfn	; parse INDEXF.SYS filename
	ld	ix,FDB_IX	;  into the FDB
	call	PFN
	jp	c,sf_err

	ld	ix,fsridx
	ld	(ix+FC.MODE),flag_r	; Read mode
	call	FOPEN		; open INDEXF.SYS
	jr	nc,sf_7

  if DBG_FIO and DEBUG
	push	af
	call	$PSTR
	defb	'S1st-E-Open idx',0
	pop	af
  endif ;DEBUG
	jp	sf_err

sf_7:
	ld	a,00000001b
	ld	(idxopn),a	; remember INDEXF.SYS is open

	ld	c,0		; length assuming '?' true
	ld	hl,(arg)	; if drive code is '?'
	ld	a,(hl)
	cp	'?'		;  we match all files on the
	jr	z,qselect	;  current drive

	; IY also points to CP/M FCB
	ld	a,(iy+fcbex)	; get extent from CP/M FCB
	cp	'?'		; if extent is wildcard then clear
	jr	z,sf_9		; module number (s2 byte)
	ld	(iy+fcbmodnum),0

sf_9:	; CP/M 2.2 BDOS calls RESELECT here to select the drive and user
	ld	(iy+fcbdrive),0	; only a single drive, no user areas

	ld	c,fcbnamlen	; length to match

qselect:
  if DBG_SRH and DEBUG
	push	bc		; show match length
	call	$PSTR
	defb	'Srch-I-Matchlen=',0
	ld	a,c
	call	$AHEX
	pop	bc
  endif ;DEBUG

	call	search		; search and construct directory entry

dir_to_user:
	ld	de,(buffa)	; copy directory buffer to user
	ld	hl,(dmaadr)	;  DMA address
	ld	c,recsiz
move:	inc	c
move0:	dec	c
	jr	z,move9
	ld	a,(de)
	ld	(hl),a
	inc	de
	inc	hl
	jr	move0
move9:	ld	hl,(aret)
	ret

sf_err:
	ld	h,0		; Search encountered an error
	ld	l,a
	ld	(errno),hl	; save the RSX280 error code
  if DBG_SRH and DEBUG
	push	af		; show the error code
	call	$PSTR
	defb	'S1st-E-Err=',0
	pop	af
	call	$AHEX
  endif ;DEBUG
	jp	no_good

;******************************************************************
; BDOS search next
;
search_next:
  if DBG_SRH and DEBUG
	call	$PSTR		; show we've been called
	defb	'Snxt',0
  endif ;DEBUG

	ld	iy,(searcha)	; point to FCB from search_first

  if DBG_SRH and DEBUG
	call	dumpfcb
  endif ;DEBUG

	call	searchn		; search for next match
	jr	dir_to_user
	
; Search for directory element of length C. The
; address of the CP/M FCB is saved at SEARCHA for
; the search_next call to use.
;
search:	ld	a,0FFh
	ld	(dirloc),a	; assume not found
	ld	hl,searchl
	ld	(hl),c		; save search length and
	ld	(searcha),iy	;  pointer to CP/M FCB
	call	set_end_dir	; init dcnt to 0FFFFh

	; rewind to start of RSX280 directory
	ld	d,0		; seek to start of
	ld	e,d		;  directory file
	ld	b,d
	ld	c,d

	ld	(dirrec),de	; directory entry pointer to beginning
	ld	(dirfsize),de	; clear previous file size too

  if DBG_SRH and DEBUG
	push	hl		; show DEBC for dir file seek
	push	bc
	push	de
	call	$PSTR
	defb	'dirr=',0
	pop	hl
	push	hl
	call	$HLHEX
	pop	hl
	ex	(sp),hl
	push	hl
	call	$HLHEX
	pop	bc
	pop	de
	pop	hl
  endif ;DEBUG

	ld	ix,fsrdir	; seek to DEBC record
	call	FSEEK
	jr	nc,sf_5

  if DBG_FIO and DEBUG
	push	af
	call	$PSTR
	defb	'S1st-E-Seek dir',0
	pop	af
  endif ;DEBUG
	jp	sf_err

sf_5:
	ld	d,0		; seek to start of
	ld	e,d		;  index file
	ld	b,d
	ld	c,d
	ld	ix,fsridx
	call	FSEEK
	jr	nc,sf_8

  if DBG_FIO and DEBUG
	push	af
	call	$PSTR
	defb	'S1st-E-Seek idx',0
	pop	af
  endif ;DEBUG
	jp	sf_err
sf_8:

  if 0
;**Dummy read - otherwise first random read of INDEXF.SYS is wrong record
	ld	de,idxentry
	ld	bc,IESZ
	call	FREAD
	jp	c,sf_err
  endif ;1

	; fall through into search next

; Search for the next directory element
searchn:
	ld	c,FALSE
	call	read_dir	; read next directory element
	call	end_of_dir
	jr	z,search_fin	; we reached the end - stop search

	ld	hl,(searcha)
	ex	de,hl		; DE points to user FCB
	ld	a,(de)		; keep searching if first char is 0E5h
	cp	empty
	jr	z,searchnext
	push	de		; are we past the end of directory?
	call	compcdr
	pop	de
	jr	nc,search_fin	; yes, stop search

searchnext:
  if 0;DEBUG
	push	hl		; show directory sector count
	push	de
	push	bc
	call	$PSTR
	defb	'srch=',0
	ld	hl,(dcnt)
	call	$HLHEX
	pop	bc
	pop	de
	pop	hl
  endif ;DEBUG
	call	getdptra	; HL = buffa + dptr
	ld	a,(searchl)	;  and search length to C
	ld	c,a
	ld	b,0		; B counts up, C counts down

searchloop:
	ld	a,c
	or	a
	jr	z,endsearch
	ld	a,(de)
	cp	'?'		; wildcard is '?'
	jr	z,searchok	; matches, so try next char
	ld	a,b		; have we reached past the extent
	cp	fcbubytes
	jr	z,searchok
	cp	fcbex		; is it the extent field?
	ld	a,(de)		; fetch FCB value
	jr	z,searchext	; skip to search extent
	sub	(hl)
	and	7Fh		; mask to 7-bits
	jr	nz,searchn	; skip if not matched
	jr	searchok	; it matched

searchext:
	; A has the FCB character to match
	; attempt an extent number match
	push	bc
	ld	c,(hl)		; directory character to C
	call	compext		; compare char
	pop	bc
	jr	nz,searchn	; skip if no match

searchok:
	; Current character matches
	inc	de
	inc	hl
	inc	b
	dec	c
	jr	searchloop

endsearch:
	; Entire name matches, return dir position
	ld	a,(dcnt)
	and	dskmsk
	ld	(lret),a	; L return is position
	ld	hl,dirloc
	ld	a,(hl)		; was it located?
	rla
	ret	nc		; no, it's 0FFh
	xor	a
	ld	(hl),a		; yes, change it to zero
	ret

search_fin:
	call	set_end_dir
	ld	a,0FFh
	ld	(aret),a
	ret

set_end_dir:
	ld	hl,-1		; set dir count to -1
	ld	(dcnt),hl
	ret

end_of_dir:
	ld	hl,dcnt		; return Z flag if at end
	ld	a,(hl)		;  of directory
	inc	hl
	cp	(hl)
	ret	nz
	inc	a		; 0FFh becomes 0
	ret

; Get pointer into fake directory buffer to HL
getdptra:
	ld	hl,(buffa)
	ld	a,(dptr)
	add	hl,a
	ret

; Check if we're past the end of the directory
compcdr:
	ld	hl,(dcnt)
	ex	de,hl		; directory counter to DE
	ld	hl,(cdrmaxa)	; address of maximum to HL
	ld	a,e
	sub	(hl)		; low(dcnt) - low(cdrmax)
	inc	hl
	ld	a,d
	sbc	a,(hl)		; high(dcnt) - high(cdrmax)
	ret			; Carry is set if cdrmax > dcnt

; Read next directory entry
read_dir:
	ld	hl,(dirmax)	; maximum dir entries -1 to DE
	ex	de,hl
	ld	hl,(dcnt)	; increment directory entry count
	inc	hl
	ld	(dcnt),hl
	push	de		; HL = DE-HL
	ex	de,hl
	subw	hl,de
	pop	de
	jr	nc,read_dir0
	jr	set_end_dir	; set dcnt to end of directory

read_dir0:
	ld	a,(dcnt)
	and	dskmsk		; use the lower 2 bits
	mult	a,dirlen	;  to point to directory entry
	ld	a,l
	ld	(dptr),a	; save pointer
	or	a		; non-zero means we already
	ret	nz		;  have read the next entry

	push	bc
	call	rd_dir
	pop	bc
	ret

rd_dir:	; Read directory into the sector pointed to by BUFFA
	; constructing a fake CP/M style directory sector

	ld	hl,(dirfsize)	; are there more extents
	ld	a,h		;  for the previous file?
	or	l
	jp	nz,rd_more	; yes, do them

	; Read next directory entry
rd_nxtd:
	ld	a,(diropn)	; have we reached the end of the
	rla			;  directory file?
	jr	c,rd_blank	; yes, make an empty extent

	xor	a
	ld	(extent),a	; clear extent value

	ld	ix,fsrdir	; read next directory entry
	ld	de,direntry	;  from RSX280 directory file
	ld	bc,DESZ
	call	FREAD
	jr	c,rd_end_dir	; Any error, assume end-of-dir
	ld	a,c		; bytes read
	cp	DESZ
	jr	z,rd_n1

rd_end_dir:
	; no more files, just fill an empty extent record
	ld	hl,diropn
	set	7,(hl)		; mark end-of-file reached

rd_blank:
	call	getdptra	; point HL to CP/M FCB entry
	ld	a,EMPTY
	ld	b,dirlen
rd_b0:	ld	(hl),a		; fill it with E5's
	inc	hl	
	djnz	rd_b0
	jp	rd_next

rd_n1:
	incw	(dirrec)	; bump directory record counter

	ld	ix,direntry	; point to directory file entry

  if DBG_SRH and DEBUG
	push	bc
	push	hl
	call	$PSTR
	defb	'dir ',0
	ldw	hl,(ix+DE.INDX)	; print index file entry number
	call	$HLHEX
	call	$SPACE
	push	ix
	pop	hl
	inc	hl
	inc	hl
	ld	b,12		; print filename
dbg_1:	ld	a,(hl)
	inc	hl
	call	$TTOUT
	djnz	dbg_1
	call	$SPACE
	ldw	hl,(ix+DE.VER)	; print version
	call	$HLHEX
	pop	hl
	pop	bc
  endif ;DEBUG

	ld	hl,(ix+DE.VER)	; only use version 1 files
	dec	hl
	ld	a,h
	or	l
	jr	nz,rd_nxtd

	ld	a,(ix+DE.NAME9)	; don't allow 9-character names

  if 0 and DBG_SRH and DEBUG
	push	af
	call	$PSTR
	defb	'9=',0
	pop	af
	push	af
	call	$AHEX
	call	$CRLF
	pop	af
  endif ;DEBUG

	cp	' '		;  (it must be a space)
	jp	nz,rd_nxtd

	ldw	hl,(ix+DE.INDX)	; get file link count
	ld	a,h
	or	l		; is it zero?
	jp	z,rd_nxtd	; yes, skip to next directory entry

	dec	hl		; it's 1-based inode number
	ld	(idxrec),hl

	multuw	hl,IESZ		; compute index file position
				; result in DEHL
	ld	b,h		; move low 16-bits to BC
	ld	c,l

  if DBG_SRH and DEBUG
	push	hl
	push	bc
	push	de
	call	$PSTR
	defb	'idxr=',0
	pop	hl
	push	hl
	call	$HLHEX
	pop	hl
	ex	(sp),hl
	push	hl
	call	$HLHEX
	pop	bc
	pop	de
	pop	hl
  endif ;DEBUG

	ld	ix,fsridx	; seek to DEBC record in INDEXF.SYS
	call	FSEEK
	jp	c,rd_end_dir	; seek error means the end

	ld	de,idxentry
	ld	bc,IESZ
	call	FREAD
	jp	c,rd_end_dir	; error reading index is also the end

  if DBG_SRH and DEBUG
	push	hl
	push	bc
	call	$PSTR
	defb	'idx',0
	ld	hl,idxentry
	ld	bc,IESZ
	call	$DUMPM
	pop	bc
	pop	hl
  endif ;DEBUG

	ld	ix,idxentry	; is it a file?
	bit	FA.FILE,(ix+IE.ATTR)
	jp	nz,rd_nxtd	; no, read next dir entry

	ldw	hl,(ix+IE.LCNT)	; if link count is zero
	ld	a,h		;  this file has been deleted
	or	l
	jp	z,rd_nxtd	; skip to next entry

	ldw	hl,(ix+IE.USED)	; 512-byte blocks used to BCHL
	ld	b,0
	ld	c,(ix+IE.USED+2)
	ex	de,hl		; low 16-bits to DE while
	ldw	hl,(ix+IE.LBCN)	;  we get last block count into
	ex	de,hl		;  DE, and low 16-bits back to HL
	ld	a,c
	or	b		; greater than 65535 blocks?
	jr	nz,sz_compute	; yes - it's a big file
	ld	a,h
	or	l		; no blocks allocated?
	jr	z,sz_zero	; yes - it's an empty file
sz_compute:
	push	de		; save last block byte count
	multuw	hl,4		; convert blocks to 128-byte sectors -> DEHL
	push	hl		; save low 16-bits on stack
	ld	h,b
	ld	l,c
	add	hl,bc
	add	hl,hl		; high byte * 4 too in BC
	add	hl,de		; add it to DE (high 16-bits)
	ex	de,hl		; back to DE
	pop	hl		; sectors now in DEHL
	ex	(sp),hl		; low 16-bits back to stack
	; HL now contains last block byte count
	divu	hl,recsiz	; divide it by a sector-size
	push	af		; save quotient in A
	ld	a,l		; is the remainder 0?
	or	a
	jr	z,sz_1		; yes - it's an exact sector size
	pop	af		; restore quotient to A
	inc	a		; add an extra sector
	jr	sz_2
sz_1:	pop	af		; restore quotient to A
sz_2:	pop	hl		; restore low 16-bits
sz_3:	cp	4		; was the last sector full?
	jr	nc,sz_dehl	; yes - no need to adjust
	inc	a
	dec	l		; no - reduce the sector count
	jp	p,sz_3		; any borrow?
	dec	h		; yes, decrement H too
	jp	p,sz_3		; any borrow?
	dec	de		; yes, decrement DE too
	jr	sz_3

sz_zero:
	ld	d,0		; file size is zero
	ld	e,d
	ld	h,d
	ld	l,d

sz_dehl:
	; DEHL now has the number of used sectors for this file.
	; We can have up to 128 sectors (128-byte) per extent
	; and extents range between 0 and 31 (32 of them), The
	; maximum filesize is 65536 sectors (8M bytes), therefore
	; we don't do larger than 65535 sectors (i.e. quit if the
	; high 16-bits of the size is not zero).
	ld	(dirfsize),hl	; save low 16-bits
	ld	a,d		; is high 16-bits non-zero?
	or	e
	jp	nz,rd_nxtd	; yes, silently ignore huge files

rd_more:

  if 0 and DBG_SRH and DEBUG
	call	$PSTR
	defb	'size=',0
	ld	hl,(dirfsize)
	call	$HLHEX
  endif ;DEBUG

	call	getdptra	; point DE to directory sector
	ld	(hl),0		; file is in user area 0
	inc	hl
	ex	de,hl
	ld	hl,direntry+DE.NAME
	ld	bc,8		; copy filename (8-chars)
	ldir
	inc	hl		; skip 9th char
	ld	bc,3		; then extension (3-chars)
	ldir
	; DE now points to the extent byte
	ld	hl,(dirfsize)	; get file size in sectors to HL
	cpw	hl,recsiz+1	; is it less than a full sector?
	jr	c,rd_single	; yes - only a single extent left

	ex	de,hl		; pointer back to HL, size in DE
	ld	a,(extent)	; copy extent byte
	ld	(hl),a
	inc	hl
	inc	hl
	inc	hl
	ld	(hl),128	; record count is 80h
	ex	de,hl		; size back to HL, ptr to DE
	subw	hl,128		; subtract 128 sectors
	ld	(dirfsize),hl	; save for next extent
	inc	(extent)	; increment extent
	jr	rd_ndp

rd_single:
	ex	de,hl		; pointer back to HL, size in DE
	ld	a,(extent)
	ld	(hl),a		; copy extent byte
	inc	hl
	inc	hl
	inc	hl
	ld	(hl),e		; record count
	ex	de,hl		; ptr back to DE
	ldw	(dirfsize),0	; clear size of file
rd_ndp:
	ex	de,hl
	ld	de,(dirrec)	; store directory entry
	inc	hl		;  number in the first
	ldw	(hl),de		;  two allocation bytes
	inc	hl
	inc	hl
	ld	de,(idxrec)	; and INDEXF.SYS record entry
	ldw	(hl),de		;  in the next two allocation
				;  bytes

rd_next:

  if 0 and DBG_SRH and DEBUG
	push	bc
	push	hl
	call	$PSTR
	defb	'entry',0
	call	getdptra	; print out directory entry
	ld	bc,dirlen
	call	$DUMPM
	call	$TTGC
	cp	'Q'
	jp	z,$EXIT
	pop	hl
	pop	bc
  endif ;DEBUG

	ld	a,(dptr)	; point to next dir entry
	add	dirlen
	and	7Fh
	ld	(dptr),a
	jp	nz,rd_dir	; do next entry

	ret			; done if dptr is zero

; Compare extent number in A with that in C
; Return non-zero if they don't match.
compext:
	push	bc
	push	af
	ld	a,(extmsk)
	cpl
	ld	b,a		; B has negated form of extent mask
	ld	a,c
	and	b
	ld	c,a		; low bits removed from C
	pop	af
	and	b		; low bits removed from a
	sub	c
	and	maxext
	pop	bc
	ret

;*******************************************************************
; BDOS call delete file
;
; On entry: IY -> pointer to FCB
;
delete:
	call	getname
	push	hl
	call	_unlink
	pop	de
	cpw	hl,-1
	jp	z,no_good
	jp	ret_hl_0

;*******************************************************************
; BDOS call rename file
;
; On entry: IY -> pointer to FCB
;
; The first filename at fcb.name is renamed to the one given
; at fcb.dm (16 byte offset).
;
rename:
	push	iy		; save pointer to CP/M FCB
  if DBG_FIO and DEBUG
	call	dumpfcb
  endif ;DEBUG
	ld	a,16
	add	iy,a		; point to the new name
	call	getname
	ld	hl,file_name
	ld	de,newnam	; copy to the new name string
	call	strcpy
;**TODO we should do a lookup to get the highest version number
	ld	hl,vers1	; append version number ";1"
	call	strcpy
	pop	iy		; restore IY and now the old name
	call	getname
	ld	hl,file_name
	ld	de,oldnam
	call	strcpy
;**TODO same as above - should lookup to get version number
	ld	hl,vers1
	call	strcpy		; append version number ";1"

	ld	hl,oldnam
	ld	ix,FDBOLD
	call	PFN		; parse old name
	jr	c,rn_err

	ld	a,FN.NAME or FN.EXT or FN.VER
	ld	(ix+F.ATTR),a	; filename and ext are valid

	ld	hl,newnam
	ld	ix,FDBNEW
	call	PFN		; parse new name
	jr	c,rn_err

	ld	a,FN.NAME or FN.EXT or FN.VER
	ld	(ix+F.ATTR),a	; filename and ext are valid

	ld	de,(FDBOLD+F.DEV) ; use old device name
	ld	a,(FDBOLD+F.UNIT)
	ld	c,a
	ld	b,LUN_SY
     	sc	.ALUN		; assign LUN to do the rename
	jr	c,rn_err

rn_3:
  if DBG_FIO and DEBUG
	call	$PSTR
	defb	'RENAME-I-from "',0
	ld	hl,oldnam
	call	$MSGHL
	call	$PRINT
	defb	'" to "',0
	ld	hl,newnam
	call	$MSGHL
	call	$PRINT
	defb	'"',0
    if 0
	ld	hl,FDBOLD
	call	dumpfdb
	ld	hl,FDBNEW
	call	dumpfdb
    endif
  endif ;DEBUG

	ld	hl,FDBOLD
	ld	de,FDBNEW
	ld	c,LUN_SY
	call	FREN		; do the rename
	jr	c,rn_err

	ld	hl,0
	or	a
	ret	z

rn_err:
	ld	h,0
	ld	l,a
  if DBG_ERR and DEBUG
	call	$PSTR
	defb	'RENAME-E-Error=',0
	call	$HLHEX
  endif ;DEBUG
	ld	(errno),hl
	ld	hl,-1
	ret

;*******************************************************************
; BDOS call read file seq.
;
; On entry: IY -> pointer to FCB
;
readfile:
	call	read128
;    nread = read(blk->desc, dmaadr, 128);
	cpw	hl,-1		; verify no error status
	jp	z,r_eof

	incw	(iy+fcbrec)	; bump record number
	ld	h,b		; byte count to HL
	ld	l,c
;    if (nread < 128)
;	dmaadr[nread] = 0x1a;
	ld	a,l		; all 128 bytes read?
	or	a
	jr	z,ret_hl_1	; none read - is EOF
	cp	128
	jr	nc,r_ok		; yes

	ex	de,hl		; no, only partial record
	ld	hl,(dmaadr)
	add	hl,de
	ld	a,CTRLZ		; add an end-of-file marker
	ld	(hl),a
r_ok:
	jp	ret_hl_0	; no errors

r_eof:
  if DBG_FIO and DEBUG
	call	$PSTR
	defb	'EOF-I-Reading LUN='
	ld	h,0
	ld	l,(iy+fcblun)
	call	$HLHEX
  endif ;DEBUG
	ld	hl,(errno)
	cpw	hl,E.EOF	; is it end-of-file?
	jp	nz,no_good
ret_hl_1:
	ld	hl,1		; yes
	ret

;*******************************************************************
; BDOS function write file seq.
;
; On entry: IY -> pointer to FCB
;
writefile:
	call	write128
;    if (write(blk->desc, dmaadr, 128) != 128 )
	ld	h,b
	ld	l,c
	cpw	hl,128
	jp	nz,no_good
	incw	(iy+fcbrec)
	jp	ret_hl_0

;*******************************************************************
; BDOS Random read/write. Max file length 8192 K
;
; On entry: IY -> pointer to FCB
;
setrandom:
	ldw	hl,(iy+fcbrec)
	ldw	(iy+fcbran),hl
	ret

readrandom:
	call	_rseek
	call	read128
;    nread = read(blk->desc, dmaadr, 128);
    	call	_rseek
	cpw	hl,-1
	jp	z,no_good
	ld	h,b		; bytes read to HL
	ld	l,c
	ld	a,l
	cp	128		; nread < 128
	jr	nc,ret_hl_0
	jp	ret_hl_1	; EOF
ret_hl_0:
	ld	hl,0
	ret

;*******************************************************************
;
writerandom:
	call	_rseek
	call	write128
;    if ( write(blk->desc, dmaadr, 128) != 128 )
	ld	h,b
	ld	l,c		; bytes written to HL
 	call	_rseek
	cpw	hl,128
	jp	nz,no_good
	jp	ret_hl_0

;*******************************************************************
; BDOS Get address of allocation vector
;
get_alloca:
	ld	hl,dpb
	ret

;*******************************************************************
; return number of available input chars in HL
char_avail:
	call	$FLUSH		; make sure all is output first
	ld	hl,0
	push	de
	ld	e,EFN_TI
	sc	.RDEF		; read event-flag
	pop	de
	or	a		; not set, nothing in buffer
	ret	z

	call	$TTGST		; is there any char in queue?
	ret	z		; no, return 0 in HL and carry set
	ld	hl,(TTQ)	; TQ.IP in L, TQ.OP in H
	ld	a,l
	cp	h		; if TQ.OP > TQ.IP the ring
	jr	nc,ca_1		;  buffers have wrapped
	add	a,64		; (TTQ input queue is 64 bytes)
ca_1:	sub	h
	ld	h,0
	ld	l,a		; return count and carry clear
	ret

;*******************************************************************
; read one character from stdin
readchar:
	call	$TTGC		; get a character
	ld	(char),a
	ret

;*******************************************************************
; write one char from A to stdout
writechar:
	push	hl		; don't change HL
	ld	c,a
	call	conout		; output keeping track of cursor
	pop	hl
	ret

;*******************************************************************
; read 128 bytes
;
; Under RSX280 - returns bytes read in BC and status in HL
; (0=no errors, -1=error with reason in errno variable)
; Also Carry flag is set on error.
read128:
	ld	h,0
	ld	l,(iy+fcblun)	; LUN in HL
	push	hl
	push	(dmaadr)
	push	128
	call	_read
;    nread = read(blk->desc, dmaadr, 128);
	pop	de
	pop	de
	pop	de
	ret

;*******************************************************************
; write 128 bytes
;
; Returns bytes written in BC
write128:
	ld	h,0
	ld	l,(iy+fcblun)
	push	hl
	push	(dmaadr)
	push	128
	call	_write
;    nread = write(blk->desc, dmaadr, 128);
	pop	de
	pop	de
	pop	de
	ret

;*******************************************************************
; CP/M Emulator set-up
;
; main(argc, argv)

main::
	ld	sp,tmpstk	; switch to local stack
	xor	a
	ld	(ttlc),a	; force input to uppercase
	ld	(diropn),a	; directory not open
	ld	(idxopn),a	; INDEXF.SYS not open
	ld	hl,luntb	; clear LUN table of
	ld	b,luntbsz	;  open files (all files
init_0:	ld	(hl),a		;  are closed)
	inc	hl
	djnz	init_0

	ldw	(CCFLG),0	; enable ctrl-C break
	ld	ix,TTQ

	call	qinit		; set-up terminal queue

	ld	de,'TI'
	ld	c,0
	ld	b,LUN_TI
	SC	.ALUN		; assign TI: to LUN_TI
	call	ATTACH		; attach with ASTs
	call	TTCLR		; clear output buffer

	call	$PRINT
	defb	CR,LF,'CP/M 2.2 emulator ',0
	ld	hl,VERSION
	call	$MSGHL
reentry:
	call	$FLINP		; flush input buffer
	call	$PRINT	; output prompt
	defb	CR,LF,'X>',0

	ld	a,2		; cursor position
	ld	(column),a
	xor	a		; reset flag to allow console echo
	ld	(compcol),a

	ld	hl,ttibuf	; point HL to input buffer text
	ld	(arg),hl	; we're calling the BDOS routine
	call	rdbuf

	ld	a,(hl)		; how many characters entered?
	or	a
	jr	z,reentry	; none

	inc	hl
	ld	a,(hl)		; look for Ctrl-Z
	cp	CTRLZ
	jp	z,$EXIT		; yes, exit

	call	getnb		; skip white-space
	jr	z,reentry	; Z means there was nothing
	cp	CR		; EOL?
	jr	z,reentry

	; HL points to the first non-blank character
	ld	ix,p_argv	; IX -> first of the argv pointers
	call	getargs		; split line into argv elements
	ld	(argc),hl	; save argc

	ld	hl,(p_argv)	; pointer to argv[0]
	ld	de,COMFCB
	call	strcpy		; copy it into filename
	ld	hl,DOTCOM
	call	strcpy		; add .COM file type

	push	COMFCB		; open the COM file
	push	flag_r
	call	_open
	pop	de		; clean-up stack
	pop	de

	cpw	hl,-1
	jr	nz,arg_5	; opened

notfnd:
	call	$CRLF
	ld	hl,(p_argv)	; not found
	call	$MSGHL		; output argv[0] followed
	call	$PRINT		;  by a '?' for unknown
	defb	'?',CR,LF,0	;  command
	jp	reentry

arg_5:				; HL contains the LUN of opened file
	push	hl		; LUN to stack
	push	tpa		; TPA address to stack
ldcom1:	push	128		; number of bytes to read at a time
	call	_read		; read sector into TPA
	jr	c,ldcom2	; an error? (most likely end of file)
	; number of bytes read returned in BC
	ld	h,b
	ld	l,c
	ld	a,h		; nothing read?
	or	l
	jr	z,ldcom2
	pop	de		; remove nchars from stack
	pop	de		; buffer address from stack
	add	hl,de		; add number of bytes read
	cpw	hl,bdos		; don't overwrite the BDOS
	jr	nc,ldcom3	; too big
	push	hl
	jr	ldcom1		; next sector

ldcom3:	; LUN still on stack
	call	_close
	pop	de
	call	$PRINT
	defb	'BAD LOAD',0
	jr	notfnd		; error

ldcom2:	pop	de		; clean up stack (byte count)
	pop	(topcom)	; save top load address
	call	_close		; (LUN is still on the stack)
	pop	de		; discard it
	; .COM file loaded
    if 0 and DEBUG
	call	$PSTR
	defb	'CPM-I-Program loaded 0100-',0
	ld	hl,(topcom)
	call	$HLHEX
	call	$CRLF
      if 0
	call	dumptpa		; let's see a dump of the TPA
      endif
    endif ;DEBUG

	ld	hl,(topcom)
	cpw	hl,tpa		; anything loaded?
	jp	z,notfnd	; no - treat as an error

	ld	hl,p_argv
	ld	de,(argc)

	;Now we assemble the command parameters at 0080h
	;argv in HL
	;argc in DE
	ld	a,e
	cp	1
	jr	nz,m_33
	ldw	(cpmdma),0
	jp	m_2		; no file arguments

m_33:	ld	bc,0		; length counter
	push	bc
	ld	de,cpmdma+2	; CPM command line buffer
	push	hl		; save argv pointer
m_3:	pop	hl		; hl pointer to argv
	inc	hl
	inc	hl		; point to next argv
	push	hl		; save argv pointer
	ld	hl,(hl)
	ld	a,(hl)
	or	a
	jr	z,m_55		; no more args
	push	hl		; save argv[i]
	call	strcpy		; copy argument from (HL) to (DE)
	ld	a,' '		; strcpy advances DE
	ld	(de),a
	inc	de
	pop	hl		; get back argv
	call	strlen		; get length of argv[1] into a
	inc	a
	pop	hl
	pop	bc		; add string length
	add	a,c
	ld	c,a
	push	bc		; save length counter
	push	hl
	jr	m_3
m_55:	pop	hl		; forget argv pointer
	pop	bc		; get length
	xor	a
	ld	(de),a		; terminate the string
	ld	a,c		; get length
	ld	(cpmdma),a
	ld	a,' '
	ld	(cpmdma+1),a
m_2:
	ld	hl,cpmdma	; set default DMA address
	ld	(dmaadr),hl

	; now set-up the CP/M default
	; File Control Block at 005Ch

	ld	hl,cpmfcb1	; clear the FCB area
	ld	b,fcblen
m_0:	ld	(hl),0
	inc	hl
	djnz	m_0

; actually this is always done - even for no parameters
;	ld	a,(argc)	; restore argc
;	cp	1		; no parameters
;	jr	z,parm_0
;	cp	2		; one parameter?
;	jr	z,parm_1	; yes

	ld	ix,(p_argv+2*2)	; point IX to p_argv[2]
	ld	hl,cpmfcb2	; point HL to second FCB area
	call	fillfcb		; copy to FCB
parm_1:
	ld	ix,(p_argv+2*1)	; point IX to p_argv[1]
	ld	hl,cpmfcb1	; point HL to first FCB area
	call	fillfcb
parm_0:

	; make BDOS and BIOS entry points
	ld	a,0c3h
	ld	(cpmwarm),a	; warm boot JP
	ld	(cpmentry),a	; BDOS entry JP
	ld	hl,warmboot
	ld	(cpmwarm+1),hl
	ld	hl,entry
	ld	(cpmentry+1),hl
	ld	hl,0
	ld	(cpmiob),hl	; IOBYTE and current drive
				;  both zero (only drive A:)

  if 0 and DEBUG
	push	hl
	call	dumppg0		; show page zero to see it's all OK
	pop	hl
  endif

	ld	a,0ffh		; enable lowercase input
	ld	(ttlc),a

	call	crlf		; program starts on a new line
	ldw	(CCFLG),0FFFFh	; disable Ctrl-C checking

	ld	sp,bdos		; set stack pointer to base of BDOS

	; Program loaded - off we go!
	ld	hl,done		; push a return address
	push	hl		; to return to the CPM X> prompt
	jp	tpa		; start transient program

;*******************************************************************
; Detach console terminal
DETACH: ld	hl,IO.DET	; change function code to detach
	ld	(attqio+Q.FUNC),hl
	; fall through

; Attach console terminal with ASTs
ATTACH:	ld	hl,attqio
	SC	.QIO		; .QIOW
	ret	c		; if queuing failed
	ld	a,(QIOSB)	; fetch return code
	or	a		; clear carry
	ret	z
	scf
	ret

;*******************************************************************
; Unsolicited character input AST routine
TTAST:	ex	(sp),hl		; fetch character from stack, save HL
	push	de
	push	bc
	push	ix
	ld	ix,TTQ
	ld	c,l		; get char into reg C for qput
	ld	a,c
	cp	03h		; ^C ?
	jr	nz,ast1
	ld	hl,CCFLG	; check Ctrl-C flag
	ld	a,(hl)
	or	a
	call	z,qinit		; clear input queue if yes
	inc	hl
	set	7,(hl)		; set ^C flag
ast1:	call	qput		; store char in queue
	ld	e,EFN_TI
	SC	.SETF		; set event flag
	pop	ix
	pop	bc
	pop	de
	pop	hl
	SC	.ASTX		; exit AST

;*******************************************************************
; Get argv[] and argc
;
; On entry: IX -> array of 10 argv pointers
;	    HL -> command string
;
; Returns:  argc in HL
;
getargs:
	push	ix
	push	hl
	ld	hl,NULL
	ld	b,10		; set argv[0..9] to NULL
arg_z:	ldw	(ix+0),hl
	inc	ix
	inc	ix
	djnz	arg_z
	pop	hl
	pop	ix

	ldw	(ix+0),hl	; save argv[0] (program name)
	ld	c,1		; for computing argc

arg_0:	ld	a,(hl)		; scan for white-space
	or	a
	jr	z,arg_2		; empty string
	cp	CR
	jr	z,arg_1a	; CR
	cp	' '
	jr	z,arg_1		; a space found
	inc	hl
	jr	arg_0

arg_1:	ld	(hl),0		; replace the space with a NUL
	inc	hl
	inc	ix
	inc	ix
	ldw	(ix+0),hl	; save next argv pointer
	inc	c		; bump argc
	ld	a,c
	cp	9		; only room for argv[0..9]
	jr	c,arg_0

arg_1b:	ld	a,(hl)		; look for CR
	or	a
	jr	z,arg_2
	cp	CR
	jr	z,arg_1a
	inc	hl
	jr	arg_1b

arg_1a:	ld	(hl),0

arg_2:	ld	ix,p_argv	; IX points to argv[0]
	ld	d,0		; DE is argc
	ld	e,c

  if 0 and DEBUG
	call	$PSTR
	defb	'argv',CR,LF,0
	ldw	hl,(ix+0)
arg_3:
	call	$PRINT
	defb	'"',0
	call	$MSGHL
	call	$PRINT
	defb	'"',CR,LF,0
	ld	a,c
	or	a
	jr	z,arg_4
	dec	c
	inc	ix
	inc	ix
	jr	arg_3
arg_4:
	call	$PSTR
	defb	'argc=',0
	ld	h,d
	ld	l,e
	call	$HLHEX
	call	$CRLF
  endif ;DEBUG

	ex	de,hl		; return argc value
	ret

;*******************************************************************
; Check if any character is available in the console buffer
;
; Returns zero in A if none available
;

$TTGST:	call	$FLUSH
	push	ix
	ld	ix,TTQ
	ld	a,(ix+TQ.OP)
	cp	(ix+TQ.IP)
	pop	ix
	ret

;*******************************************************************
; Single-character input, no echo

$TTGC:	call	$FLUSH		; send pending output to terminal
	push	ix
	push	hl
	push	de
	push	bc
ci1:	ld	e,EFN_TI
	SC	.CLEF		; clear event flag
	ld	ix,TTQ
	call	qget		; get char from input queue
	jr	nc,ci2
	ld	e,EFN_TI	; if none ready
;;	SC	.WTSE		;  then wait
	SC	.STSE
	jr	ci1
ci2:	ld	hl,ttlc
	bit	0,(hl)		; translate lowercase to uppercase?
	call	z,UCASE		; convert character if yes
	pop	bc
	pop	de
	pop	hl
	pop	ix
	ret

;*******************************************************************
; Reset terminal input queue
qinit:	xor	a
	ld	(ix+TQ.IP),a
	ld	(ix+TQ.OP),a

	ret

;*******************************************************************
; Fetch character from queue
qget:	ld	a,(ix+TQ.OP)
	cp	(ix+TQ.IP)
	scf
	ret	z		; return if buffer empty
	ld	e,a
	inc	a
	and	3Fh
	ld	(ix+TQ.OP),a
	ld	d,0
	push	ix
	add	ix,de
	ld	a,(ix+TQ.BUF)	; get char
	pop	ix
	or	a
	ret

;*******************************************************************
; Store character in queue
qput:	ld	a,(ix+TQ.IP)
	ld	e,a
	inc	a
	and	3Fh
	cp	(ix+TQ.OP)
	scf
	ret	z		; return if buffer full
	ld	(ix+TQ.IP),a
	ld	d,0
	push	ix
	add	ix,de
	ld	(ix+TQ.BUF),c	; store char
	pop	ix
	or	a
	ret

;*******************************************************************
; Flush (discard) input buffer
$FLINP: push	ix
	push	hl

	ld	ix,TTQ
	call	qinit		; reset terminal input queue

	ld	hl,ttibuf

	ld	(hl),ttibsz	; clear buffer
	inc	hl
	ld	(hl),1
	inc	hl
	ld	(hl),CTRLZ
	ld	(ttiptr),hl	; clear input line
	inc	hl
	ld	(hl),0

	pop	hl
	pop	ix
	ret

;*******************************************************************
; Character output (buffered)
$TTOUT: push	hl
	ld	hl,(ttoptr)
	ld	(hl),a		; store char in buffer
	inc	hl		; advance pointer
	ld	(ttoptr),hl
	pop	hl
	push	bc
	ld	c,a
	ld	a,(ttocnt)
	inc	a		; increase byte counter
	ld	(ttocnt),a
	cp	128		; buffer full?
	ld	a,c
	pop	bc
	jr	nc,$FLUSH	; output it if yes
	cp	LF ;CR		; CR?
	ret	nz		; return if not, else flush buffer

;*******************************************************************
; Flush any queued output to console
$FLUSH: ld	a,(ttocnt)
	or	a		; check in case the function is called
	ret	z		; separately
	push	bc
	push	de
	push	hl
snd0:	xor	a
	ld	(ttoqio+Q.SUBF),a
	ld	hl,(ttocnt)	; bytes to write
	ld	h,a
	ld	(ttoqio+Q.LEN),hl
	ld	hl,0
	ld	(QIOSB+2),hl	; clear counter of bytes sent
	ld	hl,ttoqio
	SC	.QIO		; .QIOW
	ld	hl,(QIOSB+2)	; fetch byte count
	ld	a,h
	or	l		; anything sent?
	jr	z,snd0		; keep trying if not
	ld	a,(ttocnt)
	sub	l		; all bytes sent?
	ld	(ttocnt),a
	ld	de,ttobuf
	jr	z,snd1		; return if yes
	ld	c,a		; else prepare counter of bytes to move
	ld	b,0
	ld	h,b		; just in case
	add	hl,de		; HL = src (ttobuf+sent), DE = dst (ttobuf)
	ldir			; shift buffer, we'll send the remainder later
snd1:	ld	(ttoptr),de	; set new buffer pointer (ttobuf+diff)
	pop	hl
	pop	de
	pop	bc
	ret

;*******************************************************************
TTCLR:	push	hl
	ld	hl,ttobuf
	ld	(ttoptr),hl
	xor	a
	ld	(ttocnt),a
	pop	hl
	ret

;*******************************************************************
;
; Exit program and return to RSX280
$EXIT:	call	close_all	; close all files
	call	close_dir

	call	$FLINP		; flush input buffer
	ld	c,LUN_TI
	call	DETACH
	ld	hl,EX.SUC	; exit to monitor with success
	SC	.EXIT
	halt			; we should never get here

;*******************************************************************
;
; int open(char *name,int flag)
;
; Open a file with the given "name" and access mode flag
;
; Parameters passed on the stack
;
; Returns the LUN of the open file in HL (or -1 on error)
;
_open:
    if 0 and DEBUG
	call	$PSTR
	defb	'OPEN-I-File "',0
	ldw	hl,(sp+4)
	call	$MSGHL
	call	$PRINT
	defb	'" mode ',0
	ldw	hl,(sp+2)
	call	$HLHEX
    endif ;DEBUG

	ld	hl,luntb	; look for an available LUN
	ld	bc,1
op_0:	bit	0,(hl)
	jr	z,op_1		; found LUN in BC is free
	inc	hl
	inc	c
	ld	a,c
	cp	luntbsz+1
	jr	c,op_0

    if 1
	call	$PSTR
	defb	'OPEN-F-No free LUN',0
    endif ;1

	ld	a,E.NOBUF	; use "Out of disk buffers" error
	jp	op_err

op_1:	ld	(opnltbe),hl	; save in case open fails
	set	0,(hl)		; mark this LUN as unavailable
	; LUN is in BC
	ld	(opnlun),bc	; save it

    if DBG_FIO and DEBUG
	push	bc
	call	$PSTR
	defb	'OPEN-I-Using LUN ',0
	ld	h,b
	ld	l,c
	call	$HLHEX
	pop	bc
    endif ;DEBUG

	ld	de,FCSIZ+512	; size of FSR and buffer
	ld	hl,fsr_1	; which file storage region to use?

op_2:	dec	bc		; index by LUN-1
	ld	a,c
	or	a
	jr	z,op_3
	add	hl,de
	jr	op_2

op_3:	push	hl
	pop	ix
	; IX points to the file storage region for this LUN
	ldw	hl,(sp+2)	; get flag to HL
	ld	(ix+FC.MODE),L	; set file access mode bit

	ldw	hl,(sp+4)	; point HL to name string
	push	ix
	ldw	ix,(ix+FC.FDB)  ; point IX to FCB
	call	PFN		; parse name into fcb
	pop	ix
	jr	nc,op_4		; it parsed correctly

    if DBG_FIO and DEBUG
	push	af
	call	$PSTR
	defb	'OPEN-F-Parse failed',0
	pop	af
    endif ;DEBUG
	jr	op_err		; illegal filename

op_4:	ldw	hl,(sp+2)	; is it an open for Read?
	ld	a,l
	bit	FM.RD,a		;  (or Read/Write)
	jr	nz,op_5		; yes, open existing file

	and	NOT (1 SHL FM.WR) ; are there other mode bits (other than WR)
	jr	z,op_creat
	ld	a,E.BADOP	; we don't support them for now.
	jr	op_err

op_creat:
    if DBG_FIO and DEBUG
	call	$PSTR
	defb	'OPEN-I-Create file',0
    endif ;DEBUG

	xor	a		; non-contiguous (A=0)
	ld	c,a		; number of blocks to
	ld	d,a		;  allocate (CDE=0)
	ld	e,a

	call	FCREAT		; create a new file
	jr	op_6

op_5:
    if DBG_FIO and DEBUG
	call	$PSTR
	defb	'OPEN-I-Existing file',0
    endif ;DEBUG

	call	FOPEN		; open existing file
op_6:	jp	c,op_err

    if DBG_FIO and DEBUG
	call	$PSTR
	defb	'OPEN-I-File opened',CR,LF,0
    endif ;DEBUG

	ld	hl,(opnlun)	; return the LUN of opened file
	or	a		; clear carry
	ret

op_err:	ld	l,a		; save RSX280 error in errno
	ld	h,0
	ld	(errno),hl
    if 1
	call	$PSTR
	defb	'OPEN-E-Error=',0
	call	$HLHEX
    endif
	ld	hl,(opnltbe)	; open failed - reset LUN
	res	0,(hl)		;  in-use entry
	ld	hl,-1
	scf
	ret

;*******************************************************************
; close(int index)
;
; Close the opened file with the LUN given by index
;
_close:
    if DBG_FIO and DEBUG
	call	$PSTR
	defb	'CLOSE-I-LUN=',0
	ldw	hl,(sp+2)
	call	$HLHEX
	call	$CRLF
    endif ;DEBUG

	ldw	hl,(sp+2)
	call	checklun
	jr	nc,cl_err

	ld	(opnlun),hl
	ld	b,h
	ld	c,l
	ld	de,FCSIZ+512
	ld	hl,fsr_1	; which file storage region to use?

cl_2:	dec	bc		; index by LUN-1
	ld	a,c
	or	a
	jr	z,cl_3
	add	hl,de
	jr	cl_2

cl_3:	push	hl
	pop	ix
	; IX points to the file storage region for this LUN
	call	FCLOSE		; close it
	push	af		; save status

	ld	de,(opnlun)
	dec	de
	ld	hl,luntb
	add	hl,de
	res	0,(hl)		; mark this LUN as available

	pop	af
	ret	nc		; no errors

	ld	l,a		; error code from FCLOSE
	ld	h,0

cl_err:
    if DBG_ERR and DEBUG
	push	af
	call	$PSTR
	defb	'CLOSE-E-Error',0
	pop	af
    endif ;DEBUG

	ld	(errno),hl
	ld	hl,-1
	ret

; Check the LUN in HL is valid
; return Carry Set if it is
; Return Carry clear if not and error code in HL
;
checklun:
	ld	a,h
	or	l
	jp	z,lun_err	; LUN cannot be zero
	cpw	hl,luntbsz+1
	ret	c
lun_err:
	ld	hl,E.INV	; LUN > maximum allowed
	ret

;*******************************************************************
; creat(char *name)
_creat:
    if DBG_FIO and DEBUG
	call	$PSTR
	defb	'CREAT-I-file "',0
	ldw	hl,(sp+2)
	call	$MSGHL
    endif ;DEBUG

	; just call _open
	ldw	hl,(sp+2)
	push	hl
	push	flag_w		; open for Write will create
	call	_open		;  a new file (a new version)
	pop	de
	pop	de
	ret

;*******************************************************************
; unlink(char *path)
_unlink:
    if DBG_FIO and DEBUG
	call	$PSTR
	defb	'UNLINK-I-Delete file "',0
	ldw	hl,(sp+2)
	call	$MSGHL
	call	$PRINT
	defb	'"',0
	scf
    endif ;DEBUG

	ldw	hl,(sp+2)	; copy filename
	ld	de,delnam
	call	strcpy
;**TODO - maybe lookup the highest version - or delete all versions?
	ld	hl,vers1	; add version number ";1"
	call	strcpy

	ld	hl,delnam
	ld	ix,FDBDEL
	call	PFN		; parse the filename into FDB
	jr	c,ul_err

	ld	a,FN.NAME or FN.EXT or FN.VER
	ld	(ix+F.ATTR),a	; filename, ext and vers valid

	ld	de,(FDBDEL+F.DEV)
	ld	a,(FDBDEL+F.UNIT)
	ld	c,a
	ld	b,LUN_SY
	sc	.ALUN		; assign the LUN
	jr	c,ul_err

	ld	hl,FDBDEL
	ld	c,LUN_SY
	call	FDEL		; do the delete
	jr	c,ul_err
	ld	hl,0
	or	a
	ret	z

ul_err:	ld	h,0
	ld	l,a
	ld	(errno),hl
	ld	hl,-1
	ret

;*******************************************************************
; read(int d, char *buf,unsigned nbytes)
_read:

    if DBG_FIO and DEBUG
	call	$PSTR
	defb	'READ-I-LUN=',0
	ldw	hl,(sp+6)
	call	$HLHEX
	call	$PRINT
	defb	' into ',0
	ldw	hl,(sp+4)
	call	$HLHEX
	call	$PRINT
	defb	' bytes ',0
	ldw	hl,(sp+2)
	call	$HLHEX
	call	$CRLF
    endif ;DEBUG

	ldw	ix,(sp+4)	; point to buffer
	ldw	hl,(sp+6)	; d

rd_0:	; read from a file - buffer ptr is in IX
        ld	b,h		; LUN -> BC
	ld	c,l
	ld	de,FCSIZ+512	; select FSR for this LUN
	ld	hl,fsr_1

rd_2:	dec	bc
	ld	a,c
	or	a
	jr	z,rd_3
	add	hl,de
	jr	rd_2

rd_3:	push	ix		; juggle registers
	ex	(sp),hl		; buf ptr in HL, fsr ptr on stack
	pop	ix		; fsr in IX
	ex	de,hl		; buf ptr in DE
	ldw	hl,(sp+2)	; number of bytes
	ld	b,h		;  into BC
	ld	c,l
        ; all set, now do the read
	call	FREAD
	; number of bytes read is returned in BC, CY set on error
	ld	hl,0		; no error status
	ret	nc		; done
	ld	h,0
	ld	l,a
	ld	(errno),hl	; put error code into errno
	ld	hl,-1
	scf
	ret

;*******************************************************************
; write(int d, char *buf,unsigned nbytes)
_write:

    if DBG_FIO and DEBUG
	call	$PSTR
	defb	'WRITE-I-LUN=',0
	ldw	hl,(sp+6)
	call	$HLHEX
	call	$PRINT
	defb	' from ',0
	ldw	hl,(sp+4)
	call	$HLHEX
	call	$PRINT
	defb	' bytes ',0
	ldw	hl,(sp+2)
	call	$HLHEX
	call	$CRLF
    endif ;DEBUG

	ldw	ix,(sp+4)	; point to buffer
	ldw	hl,(sp+6)	; d
	call	checklun
	jr	nc,wr_err	; invalid LUN

        ld	b,h		; LUN -> BC
	ld	c,l
	ld	de,FCSIZ+512	; select FSR for this LUN
	ld	hl,fsr_1

wr_2:	dec	bc
	ld	a,c
	or	a
	jr	z,wr_3
	add	hl,de
	jr	wr_2

wr_3:	push	ix		; juggle registers
	ex	(sp),hl		; buf ptr in HL, fsr ptr on stack
	pop	ix		; fsr in IX
	ex	de,hl		; buf ptr in DE
	ldw	hl,(sp+2)	; number of bytes
	ld	b,h		;  into BC
	ld	c,l
        ; all set, now do the write
	call	FWRITE
	; number of bytes written is returned in BC, CY set on error

    if DBG_FIO and DEBUG
	push	af
	push	bc
	call	$PSTR
	defb	'WRITE-I-Written=',0
	pop	hl
	push	hl
	call	$HLHEX
	pop	bc
	pop	af
    endif ;DEBUG

	ld	hl,0		; assume no errors
	ret	nc		; done
	ld	h,0
	ld	l,a
wr_err:	ld	(errno),hl	; put error code into errno
	ld	hl,-1
	scf
	ret

;*******************************************************************
;
; record seek (128 byte sector) for read/write random
;
; Parameters passed on stack
;
; rseek(blk->desc, blk->ranrec, type);
;       LUN , sector, type
;
; Under RSX280 we always do a byte seek

_rseek:	push	hl		; save HL
	push	de
	push	bc

	ld	h,0
	ld	l,(iy+fcblun)	; fetch the LUN
	; point IX to the RSX280 file storage region
	call	checklun
	jr	nc,sk_err	; invalid LUN
	ld	b,h		; LUN to BC
	ld	c,l
	ld	de,FCSIZ+512
	ld	hl,fsr_1
rs_1:	dec	bc		; index fsr table by LUN-1
	ld	a,c
	or	a
	jr	z,rs_3
	add	hl,de
	jr	rs_1
rs_3:	push	hl
	pop	ix		; IX now points to this file's FSR

	ldw	hl,(iy+fcbran)	; fetch desired sector from CP/M  FCB
	ldw	(iy+fcbrec),hl	; set it a the currect record in the FCB

	; convert sector offset to byte (*128)
	; and load into 32-bit byte position
	; in the DEBC registers

	multuw	hl,128		; multiply returns DEHL
	ld	b,h		;  but fseek needs DEBC
	ld	c,l
	call	FSEEK
	jr	nc,rs_2		; no errors?

	ld	h,0		; yes, error code in A
	ld	l,a
sk_err:	ld	(errno),hl      ; save it in errno

rs_2:	pop	bc
	pop	de
	pop	hl		; restore HL
	ret

;*******************************************************************
;
; BDOS function dispatch table (keep this in cseg)
	cseg

bdostable:
	defw	done		; 0 - system reset
	defw	read_console	; 1 - console read
	defw	write_console	; 2 - console write
	defw	no_good		; 3 - reader input
	defw	no_good		; 4 - punch output
	defw	no_good		; 5 - list output
	defw	direct_console	; 6 - direct console I/O
	defw	no_good		; 7 - get IO byte
	defw	no_good		; 8 - set IO byte
	defw	print_string	; 9 - print string
	defw	rdbuf		; 10 - read console buffer
	defw	console_status	; 11 - get console status
	defw	return_version	; 12 - get version
	defw	reset_dma	; 13 - reset disk system
	defw	ret_hl_0	; 14 - select disk
	defw	openfile 	; 15 - open file
	defw	closefile 	; 16 - close file
	defw	search_first	; 17 - search for first file
	defw	search_next	; 18 - search for next file
	defw	delete		; 19 - delete file
	defw	readfile	; 20 - read next record
	defw	writefile	; 21 - write next record
	defw	makefile	; 22 - create file
	defw	rename		; 23 - rename file
	defw	ret_hl_1	; 24 - get login vector
	defw	ret_hl_0	; 25 - get current disk
	defw	set_dma		; 26 - set disk DMA address
	defw	no_good		; 27 - get allocation vector
	defw	no_good		; 28 - write protect disk
	defw	ret_hl_0	; 29 - get read-only vector
	defw	no_good		; 30 - set file attributes
	defw	get_alloca	; 31 - get addr(dpb params)
	defw	ret_hl_0	; 32 - set/get user code
	defw	readrandom	; 33 - read random
	defw	writerandom	; 34 - write random
	defw	no_good		; 35 - compute file size
	defw	setrandom	; 36 - set random record
	defw	reset_dma 	; 37 - reset drive
	defw    no_good		; 38 - access drive (MP/M only)
	defw	no_good		; 39 - free drive (MP/M only)
	defw	no_good ;writerandom	; 40 - write random with zero fill
; end of BDOS dispatch table

maxbdosfn equ	(($-bdostable)/2)-1 ; should be 40 (028h)

;
; First try of a direct bios call implementation
;
	cseg

tobios	equ	(cpmbios-cpmtpa)-($-tpa)

  if tobios and 8000h		; negative (sign bit on)
    if2
	.printx /*** ERROR: BDOS area overflowed into BIOS area ***/
    endif
  else
	defs	tobios
  endif

;*******************************************************************
;
; The BIOS jump table.

bios::	jp	done		;0 Cold Boot
warmboot:
	jp	done		;1 Warm Boot
	jp	_conist		;2 Console Input Status
	jp	_conin		;3 Console Input
	jp	_conout		;4 Console Output
	jp	dummy		;5 List Output
	jp	dummy		;6 Punch Output
	jp	dummy		;7 Reader Input
	jp	dummy		;8 Home
	jp	_seldsk		;9 Select Disk
	jp	dummy		;10 Set Track
	jp	dummy		;11 Set Sector
	jp	dummy		;12 Set DMA Transfer Address
	jp	dummy		;13 Read Sector
	jp	dummy		;14 Write Sector
	jp	dummy		;15 List Output Status
	jp	dummy		;16 Sector Translate

;*******************************************************************
;
; BIOS console input
_conin:
	call	readchar
	ret

; BIOS console output
_conout:
	ld	a,c
	ld	(char),a
	jp	writechar


; BIOS console input status
_conist:
	call	char_avail
	ld	a,h
	or	l
	ret	z		; no char available
	ld	a,0ffh
	ret

; BIOS select disk
_seldsk:
  if DBG_SEL and DEBUG
	push	bc
	call	$PSTR
	defb	'SELDSK',0
	pop	bc
  endif ;DEBUG

	ld	hl,0		; assume error return value
	ld	a,c		; only a single drive A:
	or	a
	ret	nz
	ld	hl,dph
	ret

; Dummy routine for unsupported BIOS calls
dummy:
	ld	hl,biosmsg
	call	$MSGHL

; end of program run

done:
	;Prompt for next CP/M program
	ld	sp,tmpstk	; back to our stack

  if 0;DEBUG
	call	$PSTR
	defb	'CPM-I-Program exit',CR,LF,0
  endif ;DEBUG

	call	close_all
;	call	close_dir

	xor	a
	ld	(ttlc),a	; uppercase enable
	ldw	(CCFLG),0	; re-enable Ctrl-C processing
	jp	reentry		; go and get next emulator command

;*******************************************************************
;
; Close any open files
close_all:
	ld	hl,luntb
	ld	de,1		; start with LUN 1
cla_1:	bit	0,(hl)		; is it open?
	jr	z,cla_2		; no
	push	hl
	push	de		; LUN
	call	_close		; close it
	pop	de
	pop	hl
	res	0,(hl)		; mark it as closed
cla_2:	inc	hl
	inc	de		; next LUN
	ld	a,e
	cp	luntbsz+1	; are we done ?
	jr	c,cla_1		; no
	ret

close_dir:
	ld	a,(diropn)	; close directory
	or	a
	jr	z,cla_3
	ld	ix,fsrdir
	call	FCLOSE
	xor	a
	ld	(diropn),a
cla_3:	ld	a,(idxopn)	; close INDEXF.SYS
	or	a
	ret	z
	ld	ix,fsridx
	call	FCLOSE
	xor	a
	ld	(idxopn),a
	ret

;*******************************************************************
; Utility routines
;
; Convert char in A to uppercase
UCASE:	cp	'a'
	ret	c
	cp	'z'+1
	ret	nc
	and	5Fh
	ret

;*******************************************************************
; If A contains one of <=>:;_ then set Z flag bit
delimiter:
	cp	'<'
	ret	z
	cp	'='
	ret	z
	cp	'>'
	ret	z
	cp	':'
	ret	z
	cp	';'
	ret	z
	cp	'_'
	ret

;*******************************************************************
; Convert CP/M FCB name to RSX280 file name in variable file_name
; Illegal filename characters are replaced with a dash "-", and
; a wildcard '?' is translated to a '%'.
;
; on entry: IY -> pointer to FCB
;
; on exit : HL -> pointer to string.
;	    DE -> pointer to EOS.
getname:
	ld	de,file_name
	lda	hl,(iy+fcbname)	; get address of name
	ld	b,8		;  up to 8 characters
g_l1:	ld	a,(hl)
	inc	hl
	or	a		; is it NUL?
	jr	z,g_l2		; yes
	cp	' '		; is it blank?
	jr	z,g_l2		; yes
	call	chmap		; fix-up for RSX280
	ld	(de),a
	inc	de
	djnz	g_l1
g_l2:
	lda	hl,(iy+fcbext)	; get address of file extension
	ld	a,(hl)
	cp	' '		; is it blank?
	jr	z,g_l4		; no extension if blank
	ld	a,'.'		; add a '.'
	ld	(de),a
	inc	de
	ld	b,3		; now up to 3 characters
g_l3:
	ld	a,(hl)
	inc	hl
	or	a		; NUL?
	jr	z,g_l4
	cp	' '		; blank?
	jr	z,g_l4
	call	chmap		; fix-up for RSX280
	ld	(de),a
	inc	de
	djnz	g_l3
g_l4:
	xor	a
	ld	(de),a		; terminate the string with a NUL
	ld	hl,file_name	; return pointer to name
	ret

;*******************************************************************
; convert illegal RSX280 filename character to a '-'.
; (only A..Z and 0..9 are allowed), and a wildcard '?'
; to a '%'.
chmap:
	and	07Fh		; no parity, 7-bit only
	cp	'?'
	jr	z,chwild
	cp	'0'
	jr	c,chill
	cp	'9'+1
	ret	c		; '0'-'9' is OK
	cp	'A'
	jr	c,chill
	cp	'Z'+1
	ret	c		; 'A'-'Z' is OK
	cp	'a'
	jr	c,chill
	cp	'z'+1
	jr	nc,chill
	sub	a,32		; 'a'-'z' is uppercased
	ret
chill:	ld	a,'-'		; illegal is an '-'
	ret
chwild:	ld	a,'%'		; wildcard
	ret

;*******************************************************************
; Get next non-blank char.
;
; On entry: HL -> character string
; On exit:  HL -> first non-space character in string
;	    Z flag set if end of string reached
;
getnb:	ld	a,(hl)
	or	a
	ret	z
	cp	' '
	ret	nz
	inc	hl
	jr	getnb

;*******************************************************************
; Copy NUL terminated string pointed to by HL to DE
;
; Pointers are advanced to allow concatenation.
; The terminating NUL is copied. Spaces are skipped.
strcpy:
s_lo:	ld	a,(hl)
	cp	' '
	jr	z,s_sp
	ld	(de),a
	or	a
	ret	z		; end of string
	inc	hl
	inc	de
	jr	s_lo
s_sp:	xor	a		; space means end too
	ld	(de),a
	ret

;*******************************************************************
; return length of NUL terminated string pointed to by HL in A
strlen:
	push	bc
	ld	c,0
sl_lo:
	ld	a,(hl)
	or	a
	jr	z,sl_12
	inc	c
	inc	hl
	jr	sl_lo
sl_12:	ld	a,c
	pop	bc
	ret


;*******************************************************************
;
; CP/M BDOS emulator variables

biosmsg:
	defb	"Unimplemented BIOS call"
	defb	CR,LF,0
biosml	equ	$-biosmsg-1

oldstk:	defs	2		; saved stack pointer
arg:	defs	2		; entry argument from DE
func:	defs	2		; entry function code from C
dmaadr:	defs	2		; current DMA address
char:	defs	2
errno:	defs	2		; error code
lret:
aret:	defs	2		; address value return result
dirloc:	defs	1		; directory entry located

;*******************************************************************
;
; These routines are for the emulator.  They do not
; update the cursor position like their CP/M counterparts
;
;Newline
$CRLF:	call	$PRINT
	defb	CR,LF,0
	ret

$PSTR:
	call	$CRLF
	ld	a,'%'
	call	$TTOUT

;Print in-line message terminated by a NUL
$PRINT:
	ex	(sp),hl
	call	$MSGHL
	ex	(sp),hl
	ret

;Print message pointed to by HL terminated by a NUL
$MSGHL:	ld	a,(hl)
	inc	hl
	or	a
	ret	z
	call	$TTOUT
	jr	$MSGHL

;*******************************************************************
;
; Debugging routines

  if DEBUG

; Print three spaces
$SPACE3:
	call	$SPACE
	call	$SPACE

;Print space
$SPACE:	ld	a,' '
	jp	$TTOUT

;Print contents of HL in hexadecimal
$HLHEX:	ld	a,h
	call	$AHEX
	ld	a,l

;Print contents of A in hexadecimal
$AHEX:	push	af
	rrca
	rrca
	rrca
	rrca
	call	$CHEX
	pop	af
$CHEX:	and	0Fh
	add	a,90h
	daa
	adc	a,40h
	daa
	jp	$TTOUT

    if 1
; Dump memory starting at address in HL for BC bytes
$DUMPM:	push	hl		; save address and
	push	bc		;  count on stack
dm_0:	call	$CRLF
	call	$HLHEX		; print address in hex
	ld	a,':'
	call	$TTOUT
	call	$SPACE
	ld	a,l
	and	0Fh
	jr	z,dm_1
dm_7:	push	af		; space align
	call	$SPACE3
	pop	af
	dec	a
	jr	nz,dm_7
dm_1:	ld	a,(hl)		; fetch next
	call	$AHEX		;  and output it in hex
	call	$SPACE
	inc	hl
	dec	bc
	ld	a,l		; have we done 16?
	and	0Fh
	jr	z,dm_9		; yes
dm_2:	ld	a,b		; have we finished?
	or	c
	jr	nz,dm_1		; not zero - keep going
	ld	a,l
dm_10:	and	0Fh		; space align
	jr	z,dm_9
	push	af
	call	$SPACE3
	pop	af
	inc	a
	jr	dm_10

dm_9:	pop	bc
	pop	hl		; go back 16
	ld	a,l
	and	0Fh
	jr	z,dm_3
dm_8:	push	af		; space align
	call	$SPACE
	pop	af
	dec	a
	jr	nz,dm_8
dm_3:	ld	a,(hl)		; and output them in ASCII
	and	7Fh
	cp	7Fh
	jr	z,dm_5
	cp	' '
	jr	nc,dm_4
dm_5:	ld	a,'.'
dm_4:	call	$TTOUT
	inc	hl
	dec	bc
	ld	a,b
	or	c
	jr	z,dm_6
	ld	a,l
	and	0Fh
	jr	nz,dm_3		; repeat until we're done
	push	hl		; re-save pointer
	push	bc
	jr	dm_0

dm_6:
	jp	$CRLF
    endif ;0

    if 1
dumpfdb:
	push	bc
	push	hl
	call	$PSTR
	defb	'fdb at ',0
	call	$HLHEX
	call	$CRLF
	ld	bc,FINFSZ
	call	$DUMPM
	pop	hl
	pop	bc
	ret
;
dumpfcb:
	push	bc
	call	$PSTR
	defb	'fcb at ',0
	push	iy		; CP/M FCB pointer is in IY
	ex	(sp),hl		; move it to HL and save old HL
	call	$HLHEX
	call	$CRLF
	ld	bc,fcblen
	call	$DUMPM
	pop	hl
	pop	bc
	ret
    endif

    if 0
dumppg0:
	push	bc
	push	hl
	call	$PSTR
	defb	'page0',0
	ld	hl,0000h
	ld	bc,100h
	call	$DUMPM
	pop	hl
	pop	bc
	ret
    endif

    if 0
dumptpa:
	push	bc
	push	hl
	call	$PSTR
	defb	'tpa',0
	ld	bc,(topcom)
	dec	b
	ld	hl,tpa
	call	$DUMPM
	pop	hl
	pop	bc
	ret
    endif

    if 0
; Dump out the FSR and FDB in hex.  IX points to FSR
;
dumpfsr:
	push	bc
	push	hl		; save HL and BC
	call	$PSTR		; start by dumping the FDB
	defb	'FDB',CR,LF,0
	ldw	hl,(ix+FC.FDB)	; point HL to FDB
	ld	bc,FINFSZ
	call	$DUMPM
	call	$PSTR		; now the FSR
	defb	'FSR',CR,LF,0
	push	ix		; get the FSR pointer to HL
	pop	hl
	ld	bc,FCSIZ
	call	$DUMPM
	pop	hl
	pop	bc
	ret
    endif ;0

  endif ;DEBUG

;*******************************************************************
; Console handlers
;
; Read console character to A
conin:	ld	hl,kbchar	; any previous character seen?
	ld	a,(hl)
	ld	(hl),0
	or	a
	ret	nz		; yes, return it
	jp	_conin		; else call BIOS

; Read console character with echo
conech:	call	conin
	call	echoc
	ret	c
	push	af
	ld	c,a
	call	tabout
	pop	af
	ret

; Check for printable char in A
;
; Return Z bit set if terminator found
; and Carry set if non-printable
echoc:
	cp	CR
	ret	z
	cp	LF
	ret	z
	cp	TAB
	ret	z
	cp	BS
	ret	z
	cp	' '
	ret

; Check for character ready
conbrk:	ld	a,(kbchar)
	or	a
	jr	nz,conb1	; skip if active kbchar
	call	_conist		; call BIOS
	and	1
	ret	z		; none available
	call	_conin		; call BIOS to read it
	cp	13h		; is it a Ctrl-S?
	jr	nz,conb0
	call	_conin		; yes, get another char
	cp	ETX		; is it a Ctrl-C?
	jp	z,done		; yes, exit the program
	xor	a		; no, return with zero in A
	ret

conb0:	ld	(kbchar),a	; save character
conb1:	ld	a,1		; return non-zero
	ret

; Show a control character in printable form
ctlout:	ld	a,c
	call	echoc
	jr	nc,tabout	; not a control char
	push	af
	ld	c,'^'		; output caret
	call	conout
	pop	af
	or	'@'		; make it printable
	ld	c,a
tabout:	ld	a,c
	cp	TAB		; tab?
	jp	nz,conout
tab0:
	call	space		; expand tabs to the right number
	ld	a,(column)	;  of spaces
	and	07h
	jr	nz,tab0
	ret

; Cancel RDLIN input line ready for re-input
crlfp:
	ld	c,'#'		; signal a deleted line with a "#"
	call	conout
	call	crlf
crlfp0:	ld	a,(column)	; move the cursor back to starting
	ld	hl,strtcol	; position
	cp	(hl)
	ret	nc
	call	space
	jr	crlfp0

;*******************************************************************

VERSION: defb	memsize/10+'0',memsize mod 10 +'0','K V0.99'
  if DEBUG
	defb	' [DEBUG]'
  endif ;DEBUG
	defb	CR,LF,'Use ^Z followed by Return/Enter to exit.'
	defb	CR,LF,0

argc:	defs	2
p_argv:	defs	10*2		; room for 10 pointers (0..9)

vers1:	defb	';1'
NULL:	defb	0

COMFCB:	defs	FNSZ		; RSX280 filespec of CP/M .COM file

DOTCOM:	defb	'.COM',0

mdfn:	defb	'MASTER',0	; master directory filename
dirtype:
	defb	'.DIR;1',0	; directory fileext

idxfn:	defb	'SY:[MASTER]INDEXF.SYS;1',0 ; index filename

dirfn:	defb	'SY:[MASTER]'	; users directory location
dirname:
	defs	16		; directory.DIR;1 (16 chars)

cdname:
	defs	16		; current directory name

searcha:
	defs	2		; search address
searchl:
	defs	1		; search length

dptr:	defs	1		; directory entry pointer 0,32,64,96
dcnt:	defs	2		; directory counter

direntry:
	defs	DESZ		; directory file record
dirfsize:
	defs	2		; 16-bit file size in sectors

diropn:	defb	0		; directory file is open flag
dirrec:	defs	2
idxopn:	defb	0		; INDEXF.SYS file is open flag
idxentry:
	defs	IESZ		; index file record
idxrec:	defs	2

topcom:	defs	2

; BIOS Disk Parameter Header
; We simulate a single 8MB drive with blocksize 4096
; and 1024 directory entries
dph:	defw	0		; no sector translation
cdrmax:	defw	maxdir		; scratchpad - current directory maximum
curtrk:	defw	0		; scratchpad - current track
currec:	defw	0		; scratchpad - current record
buffa:	defw	bufdir		; pointer to directory sector buffer
	defw	dpb		; disk parameter header
	defw	0,0		; no check vector or allocation vector

dpb:
sectpt:	defw	1024		; sectors per track, 64 tracks
blkshf:	defb	5		; block shift factor (block size 4096)
blkmsk:	defb	31		; block mask
extmsk:	defb	1		; extent mask
maxall:	defw	2048-1		; dsm (disk size in 4K blocks)-1
dirmax:	defw	maxdir-1	; drm (1024 dir entries)
dirblk:	defb	0FFh,0h		; al0, al1 (need 8 groups for directory)
chksiz:	defw	0		; check vector size (none = fixed disk)
offset:	defw	0		; reserved tracks

cdrmaxa:
	defw	cdrmax

; Search directory sector buffer
bufdir:	defs	128		; the faked directory sector
extent:	defs	1		; the faked extent number

file_name:
	defs	20		; holds converted RSX file name

; RSX280 filename strings
; enough for filename.ext;1 (15 chars including NUL terminator)
delnam:
newnam:	defs	16		; holds old name for rename
oldnam:	defs	16		; holds new name for rename

; QIO commands for console terminal
IO.ATA	equ	IO.ATT OR (TF.AST SHL 8)	; attach with AST
;
attqio:	QIOW$	IO.ATA,LUN_TI,EFN_TO,QIOSB,,<TTAST>	; attach console
ttoqio:	QIOW$	IO.WVB,LUN_TI,EFN_TO,QIOSB,,<ttobuf,,,,0>	; console output

; QIO status
QIOSB:	defs	4

; Keeps track of LUNs in-use
luntbsz	equ	4
luntb:	defs	luntbsz		; LUN "in-use" table
				; one byte for each LUN 1-4
				; non-zero means file open
opnltbe: defs	2		; current luntb entry
opnlun:	defs	2		; the LUN being accessed

; Console terminal input queue
TTQ:	defs	1		; input position
	defs	1		; output position
	defs	64		; buffer

ttlc:	defs	1		; lowercase input flag

; Console input line
ttiptr:	defw	ttibuf		; pointer to buffer
ttibuf:	defb	ttibsz		; first byte has size
	defb	0		; number of characters in buffer
	defs	ttibsz+2	; the line buffer

; Console output line
ttocnt:	defb	0		; output count
ttoptr:	defw	ttobuf		; output pointer
ttobuf:	defs	128		; buffer

CCFLG:	defs	2		; ctrl-C break flag

; BDOS console storage (RDBUF)
compcol:
	defb	0		; output flag (non zero means no output)
strtcol:
	defb	0		; starting position for cursor
column:	defb	0		; cursor position (0=start of line)
kbchar:	defb	0

; We use FCS to access files.  These are the File Storage Regions for
; each of the LUNs that are used (only 4 at present)

; Note: The file access mode bits are overwritten by the _open
; routine and we use a common event flag for access to all files

fsr_1:	FSR$	FDB_F1,<1 SHL FM.RD>,LUN_F1,EFN_F1
fsr_2:	FSR$	FDB_F2,<1 SHL FM.WR>,LUN_F2,EFN_F2
fsr_3:	FSR$	FDB_F3,<1 SHL FM.WR>,LUN_F3,EFN_F3
fsr_4:	FSR$	FDB_F4,<1 SHL FM.WR>,LUN_F4,EFN_F4

; Directory file
fsrdir:	FSR$	FDB_D,<1 SHL FM.RD>,LUN_D,EFN_D
; Index file
fsridx:	FSR$	FDB_IX,<1 SHL FM.RD>,LUN_IX,EFN_IX

; File Descriptor Blocks
FDB_F1:	defs	FINFSZ
FDB_F2:	defs	FINFSZ
FDB_F3:	defs	FINFSZ
FDB_F4:	defs	FINFSZ

; FDBs for file rename/delete
FDBDEL:				; delete uses same as rename FDB
FDBNEW:	defs	FINFSZ		; new name FDB
FDBOLD:	defs	FINFSZ		; old name FDB
  if 0
FDBSER:	defs	FINFSZ		; search file-spec FDB
  endif ;0
FDB_D:	defs	FINFSZ		; directory FDB
FDB_IX:	defs	FINFSZ		; INDEXF.SYS FDB

;*******************************************************************
;
; Stack
	cseg

    if (($-tpa) and 1)		; even address boundary
	defs	1
    endif

	defs	256
tmpstk:

	end
